<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cinema Ghar Index</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&family=Product+Sans:wght@400;700&display=swap" rel="stylesheet">

    <style>
      /* --- START OF INLINED style.css --- */
      /* --- PASTE YOUR ENTIRE PREVIOUS style.css HERE --- */
      /* ... (Your existing long CSS) ... */

      /* --- ADDED STYLES FOR GROUPING --- */
      #cinemaghar-container tr.group-header-row {
          background-color: #f0f2f5; /* Slightly different background for group headers */
          font-weight: 600;
      }
      #cinemaghar-container tr.group-header-row:hover {
          background-color: #e9ecef;
      }

      #cinemaghar-container td.col-filename-group {
          font-weight: 600;
          color: var(--text-color); /* Not a link */
          cursor: default;
      }
       #cinemaghar-container td.col-filename-group:hover {
          text-decoration: none;
          color: var(--text-color);
       }

      #cinemaghar-container tr.group-child-row td {
          /* Optional: Add visual indentation */
          /* padding-left: 25px; */
          border-top: 1px dashed #e0e0e0; /* Separator for child items */
      }
       /* Optional: More specific indentation for first cell */
       #cinemaghar-container tr.group-child-row td:first-child {
            padding-left: 25px; /* Indent the ID */
       }

       /* Ensure nested action rows don't get double dashed border */
       #cinemaghar-container tr.action-row td {
           border-top: none;
       }
       #cinemaghar-container tr.group-child-row + tr.action-row td {
            border-top: none;
       }


      #cinemaghar-container button.expand-group-button {
          padding: 5px 10px;
          font-size: 11px;
          font-weight: 500;
          min-width: 70px;
          background-color: var(--button-secondary-bg);
          color: white !important;
          border-radius: var(--border-radius-sm);
          border: none;
          cursor: pointer;
          transition: background-color 0.2s ease;
      }
      #cinemaghar-container button.expand-group-button:hover {
          background-color: var(--button-secondary-hover);
      }
       #cinemaghar-container button.expand-group-button[aria-expanded="true"] {
           background-color: #5a6268; /* Slightly darker when expanded */
       }

      /* Ensure View button in group header also looks distinct if needed */
       #cinemaghar-container tr.group-header-row td.col-view {
           text-align: center;
       }

        /* --- Responsive Adjustments for Grouping --- */
        @media screen and (max-width: 768px) {
            #cinemaghar-container tr.group-child-row td:first-child {
                 padding-left: 15px; /* Less indentation on mobile */
            }
            #cinemaghar-container button.expand-group-button {
                 padding: 4px 8px;
                 font-size: 10px;
                 min-width: 60px;
            }
            /* Adjust child filename padding if needed */
             #cinemaghar-container tr.group-child-row td.col-filename {
                 /* padding-left: 15px; /* Match first-child indent? Optional */
             }
        }
      /* --- END OF ADDED GROUPING STYLES --- */

      /* --- END OF INLINED style.css --- */
    </style>

</head>
<body>
<!-- Main Container: Holds everything, controls background/shadow -->
<div id="cinemaghar-container">

  <!-- Page Loader: Shown initially, hidden by JS after load -->
  <div id="page-loader">
      <div class="spinner-container" role="status" aria-live="polite">
          <div class="spinner"></div>
          <span>Loading Cinema Ghar Index...</span>
      </div>
  </div>

  <!-- Search Focus Area: Centered initially, moves top when results show -->
  <div id="search-focus-area" style="display: flex;"> <!-- Ensure default display is set -->
      <!-- Simplified Title -->
      <h1 class="simple-title" onclick="resetToHomepage()">
          Cinema Ghar Index
      </h1>
      <!-- Right-aligned Signature -->
      <p class="signature">Curated with ❣️ by The_SabhyaPlayer</p>

      <!-- Search Input -->
      <div class="search-input-wrapper">
          <input type="search" id="mainSearchInput" placeholder="Search your movie, series, or file" autocomplete="off" aria-label="Search for movies, series, or files"/>
          <div id="searchInputSuggestions"></div>
          <button class="button" id="searchSubmitButton" onclick="handleSearchSubmit()">Search</button>
      </div>
      <!-- Optional buttons -->
      <div class="search-actions">
           <!-- Buttons here if needed -->
      </div>
      <!-- Updates Preview Section (only shown on homepage) -->
      <div id="updates-preview-section" style="display: none;">
          <h3>Recently Added</h3>
          <div id="updates-preview-list">
              <!-- JS Populates: Initial spinner -> items or 'No updates' message -->
              <div class="loading-inline-spinner" role="status" aria-live="polite">
                  <div class="spinner"></div>
                  <span>Loading updates...</span>
              </div>
          </div>
          <button id="showMoreUpdatesButton" style="display: none;" onclick="appendMoreUpdates()">Show More</button>
      </div>
  </div> <!-- End #search-focus-area -->

  <!-- Results Area: Hidden initially, displayed below search when active -->
  <main id="results-area">
      <!-- MODIFICATION: Added Back Button specific to Results View -->
      <button id="backToHomeButtonResults" class="button back-button" onclick="resetToHomepage()">
          &larr; Back to Home
      </button>

      <!-- Filter Area within Results -->
      <div class="results-filter-area">
          <div class="filter-group">
              <label for="mainQualityFilterSelect">Filter by Quality:</label>
              <select id="mainQualityFilterSelect">
                  <option value="">All Qualities</option>
                  <!-- Options populated by JS -->
              </select>
          </div>
          <!-- Add more filters here if needed -->
      </div>

      <!-- Tab Navigation -->
      <nav class="tab-navigation">
          <button class="tab-button active" id="allFilesTabButton" onclick="switchTab('allFiles')">All Files</button>
          <button class="tab-button" id="moviesTabButton" onclick="switchTab('movies')">Movies</button>
          <button class="tab-button" id="seriesTabButton" onclick="switchTab('series')">Series</button>
      </nav>

      <!-- Tab Content Area -->
      <div class="tab-content">
          <!-- All Files Panel -->
          <div id="allFilesTabPanel" class="active">
              <div class="table-container">
                  <table id="allFilesTable">
                      <thead>
                          <tr>
                              <th class="sortable col-id" data-sort-key="id">#<span class="sort-indicator"></span></th>
                              <th class="sortable col-filename" data-sort-key="filename">Filename<span class="sort-indicator"></span></th>
                              <th class="sortable col-size" data-sort-key="size">Size<span class="sort-indicator"></span></th>
                              <th class="sortable col-quality" data-sort-key="quality">Quality<span class="sort-indicator"></span></th>
                              <th class="sortable col-updated" data-sort-key="lastUpdated">Updated<span class="sort-indicator"></span></th>
                              <th class="col-view">View / Expand</th> <!-- Modified Header -->
                          </tr>
                      </thead>
                      <tbody id="allFilesTableBody">
                         <!-- JS renders initial message here -->
                         <tr><td colspan="6" class="status-message">Enter search term above.</td></tr>
                      </tbody>
                  </table>
              </div>
              <div class="pagination-container" id="allFilesPaginationControls" style="display: none;"></div>
          </div>

           <!-- Movies Panel -->
          <div id="moviesTabPanel">
              <div class="table-container">
                  <table id="moviesTable">
                      <thead>
                          <tr>
                              <th class="sortable col-id" data-sort-key="id">#<span class="sort-indicator"></span></th>
                              <th class="sortable col-filename" data-sort-key="filename">Filename<span class="sort-indicator"></span></th>
                              <th class="sortable col-size" data-sort-key="size">Size<span class="sort-indicator"></span></th>
                              <th class="sortable col-quality" data-sort-key="quality">Quality<span class="sort-indicator"></span></th>
                              <th class="sortable col-updated" data-sort-key="lastUpdated">Updated<span class="sort-indicator"></span></th>
                              <th class="col-view">View / Expand</th><!-- Modified Header -->
                          </tr>
                      </thead>
                      <tbody id="moviesTableBody"></tbody>
                  </table>
              </div>
              <div class="pagination-container" id="moviesPaginationControls" style="display: none;"></div>
          </div>

           <!-- Series Panel -->
          <div id="seriesTabPanel">
              <div class="table-container">
                  <table id="seriesTable">
                       <thead>
                          <tr>
                              <th class="sortable col-id" data-sort-key="id">#<span class="sort-indicator"></span></th>
                              <th class="sortable col-filename" data-sort-key="filename">Filename<span class="sort-indicator"></span></th>
                              <th class="sortable col-size" data-sort-key="size">Size<span class="sort-indicator"></span></th>
                              <th class="sortable col-quality" data-sort-key="quality">Quality<span class="sort-indicator"></span></th>
                              <th class="sortable col-updated" data-sort-key="lastUpdated">Updated<span class="sort-indicator"></span></th>
                              <th class="col-view">View / Expand</th><!-- Modified Header -->
                          </tr>
                      </thead>
                      <tbody id="seriesTableBody"></tbody>
                  </table>
              </div>
              <div class="pagination-container" id="seriesPaginationControls" style="display: none;"></div>
          </div>
      </div> <!-- End .tab-content -->
  </main> <!-- End #results-area -->

  <!-- Shared Item View Area (Hidden initially) -->
  <main id="shared-item-view">
      <button id="backToHomeButtonShared" class="button back-button" onclick="resetToHomepage()">
          &larr; Back to Home
      </button>
      <div id="shared-item-content">
          <!-- JS populates this with shared item details or error message -->
          <div class="loading-inline-spinner" role="status" aria-live="polite">
              <div class="spinner"></div>
              <span>Loading shared item...</span>
          </div>
      </div>
       <!-- Video player will be moved inside shared-item-content when playing from share view -->
  </main> <!-- End #shared-item-view -->


  <!-- Video Player Container - Initially hidden, moved dynamically by JS -->
  <div class="video-container" id="videoContainer" style="display: none;">
     <!-- Video Player Content (Unchanged) -->
       <button class="close-btn" onclick="closePlayer(event)" aria-label="Close video player">✖ Close</button>
      <div id="audioWarning" style="display: none;"></div>
      <div id="videoTitle"></div>
      <video id="html5VideoPlayer" controls autoplay controlsList="nodownload noremoteplayback">
          Your browser does not support the video tag.
      </video>
      <div class="custom-controls" id="customControlsContainer">
          <button class="button" onclick="seekVideo(-10)">« 10s</button>
          <button class="button" onclick="seekVideo(10)">10s »</button>
          <button class="button" id="muteButton" onclick="toggleMute()" aria-pressed="false">Mute</button>
          <div class="player-control-group">
              <label for="volumeSlider">Vol:</label>
              <input type="range" id="volumeSlider" min="0" max="1" step="0.05" value="1" oninput="setVolume(this.value)" onchange="setVolume(this.value)" aria-label="Volume control">
          </div>
          <select id="audioTrackSelect" onchange="changeAudioTrack(this)" title="Select Audio Track" style="display: none;" aria-label="Select audio track"></select>
          <div class="player-control-group">
             <label for="playbackSpeedSelect">Speed:</label>
             <select id="playbackSpeedSelect" onchange="setPlaybackSpeed(this.value)" aria-label="Select playback speed">
                <option value="0.5">0.5x</option>
                <option value="0.75">0.75x</option>
                <option value="1" selected>1x</option>
                <option value="1.25">1.25x</option>
                <option value="1.5">1.5x</option>
                <option value="2">2x</option>
             </select>
          </div>
          <button class="button" onclick="toggleFullscreen()">Fullscreen</button>
      </div>
      <div class="vlc-copy-box" id="vlcBox" style="display:none;">
          <strong>External Player URL:</strong>
          <code id="vlcText"></code>
          <!-- Feedback span INSIDE vlcBox - Now uses shared class -->
          <span class="copy-feedback" role="status" aria-live="polite">Copied!</span>
      </div>
  </div> <!-- End #videoContainer -->

   <!-- Footer Section -->
  <footer id="page-footer" style="display: flex;"> <!-- Ensure default display is set -->
       <!-- Footer Content (Unchanged) -->
       <div class="footer-buttons">
          <a href="https://t.me/The_Sabhyaplayer_bot" target="_blank" rel="noopener noreferrer" class="button telegram-button">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" aria-hidden="true" focusable="false">
                  <path d="M97.9,161.4l-2.8,29.9c3.4,0,4.9-1.7,6.8-3.6l14.1-13.6l29.4,21.7c5.4,3.1,9.3,1.5,10.8-4.9l19.9-93.5c1.8-7.8-2.4-11.5-7.5-9.3L36.4,127.1c-7.6,3-7.6,7.5-1.3,9.6l30.2,9.4l70.4-44.3c3.3-2,6.1-0.9,3.6,1.4L97.9,161.4z"/>
              </svg>
              <span>Contact The_Sabhyaplayer</span>
          </a>
          <a href="https://t.me/Cinemaghar_Lobby" target="_blank" rel="noopener noreferrer" class="button telegram-button">
               <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" aria-hidden="true" focusable="false">
                   <path d="M97.9,161.4l-2.8,29.9c3.4,0,4.9-1.7,6.8-3.6l14.1-13.6l29.4,21.7c5.4,3.1,9.3,1.5,10.8-4.9l19.9-93.5c1.8-7.8-2.4-11.5-7.5-9.3L36.4,127.1c-7.6,3-7.6,7.5-1.3,9.6l30.2,9.4l70.4-44.3c3.3-2,6.1-0.9,3.6,1.4L97.9,161.4z"/>
               </svg>
              <span>Join Telegram Channel</span>
          </a>
      </div>
      <p class="footer-text">&copy; 2025 Cinema Ghar Index  |  Maintained by The_SabhyaPlayer  |  We Do not own any data  |  We Just Index it | All Credit goes to Original Rippers.</p>
  </footer> <!-- End #page-footer -->

  <!-- Main Error Display Area -->
  <div id="main-error-area" aria-live="assertive"></div>

</div> <!-- End #cinemaghar-container -->

<!-- START OF INLINED SCRIPT BLOCK (MODIFIED FOR GROUPING) -->
<script>
       // --- START OF INLINED script.js (MODIFIED FOR GROUPING) ---
       (function() {
           'use strict';

           // ===========================================================
           // JAVASCRIPT SECTION (Updated for Grouping)
           // ===========================================================
           const config = {
               HDR_LOGO_URL: "https://as1.ftcdn.net/v2/jpg/05/32/83/72/1000_F_532837228_v8CGZRU0jy39uCtqFRnJz6xDntrGuLLx.webp",
               FOURK_LOGO_URL: "https://i.pinimg.com/736x/85/c4/b0/85c4b0a2fb8612825d0cd2f53460925f.jpg",
               ITEMS_PER_PAGE: 50,
               LOCAL_STORAGE_KEY: 'cinemaGharState_v10_grouping', // Changed key
               PLAYER_VOLUME_KEY: 'cinemaGharPlayerVolume',
               PLAYER_SPEED_KEY: 'cinemaGharPlayerSpeed',
               SEARCH_DEBOUNCE_DELAY: 300,
               SUGGESTIONS_DEBOUNCE_DELAY: 250,
               MAX_SUGGESTIONS: 50,
               UPDATES_PREVIEW_INITIAL_COUNT: 10,
               UPDATES_PREVIEW_LOAD_MORE_COUNT: 10,
               MOVIE_DATA_API_URL: '/api/movies'
           };

           // --- DOM Element References (Mostly Unchanged) ---
           const container = document.getElementById('cinemaghar-container');
           const pageLoader = document.getElementById('page-loader');
           // ... (keep all other existing DOM references) ...
           const allFilesTableBody = document.getElementById('allFilesTableBody');
           const moviesTableBody = document.getElementById('moviesTableBody');
           const seriesTableBody = document.getElementById('seriesTableBody');
           const allFilesTableHead = document.querySelector('#allFilesTable thead');
           const moviesTableHead = document.querySelector('#moviesTable thead');
           const seriesTableHead = document.querySelector('#seriesTable thead');
           // ... (keep all other existing DOM references) ...
           const videoContainer = document.getElementById('videoContainer');
            const videoElement = document.getElementById('html5VideoPlayer');
            const videoTitle = document.getElementById('videoTitle');
            const vlcBox = document.getElementById('vlcBox');
            const vlcText = document.getElementById('vlcText');
            const audioWarningDiv = document.getElementById('audioWarning');
            const muteButton = document.getElementById('muteButton');
            const volumeSlider = document.getElementById('volumeSlider');
            const playbackSpeedSelect = document.getElementById('playbackSpeedSelect');
            const customControlsContainer = document.getElementById('customControlsContainer');
            const audioTrackSelect = document.getElementById('audioTrackSelect');
            const searchInput = document.getElementById('mainSearchInput');
            const suggestionsContainer = document.getElementById('searchInputSuggestions');
            const qualityFilterSelect = document.getElementById('mainQualityFilterSelect');
            const searchFocusArea = document.getElementById('search-focus-area');
            const resultsArea = document.getElementById('results-area');
            const sharedItemView = document.getElementById('shared-item-view');
            const sharedItemContent = document.getElementById('shared-item-content');
            const mainErrorArea = document.getElementById('main-error-area');
            const updatesPreviewSection = document.getElementById('updates-preview-section');
            const updatesPreviewList = document.getElementById('updates-preview-list');
            const showMoreUpdatesButton = document.getElementById('showMoreUpdatesButton');
            const tabNavigation = document.querySelector('.tab-navigation');
            const tabContent = document.querySelector('.tab-content');
            const allFilesTabButton = document.getElementById('allFilesTabButton');
            const moviesTabButton = document.getElementById('moviesTabButton');
            const seriesTabButton = document.getElementById('seriesTabButton');
            const allFilesTabPanel = document.getElementById('allFilesTabPanel');
            const moviesTabPanel = document.getElementById('moviesTabPanel');
            const seriesTabPanel = document.getElementById('seriesTabPanel');
            const allFilesPaginationControls = document.getElementById('allFilesPaginationControls');
            const moviesPaginationControls = document.getElementById('moviesPaginationControls');
            const seriesPaginationControls = document.getElementById('seriesPaginationControls');
            const backToHomeButtonResults = document.getElementById('backToHomeButtonResults');
            const backToHomeButtonShared = document.getElementById('backToHomeButtonShared');
            const pageFooter = document.getElementById('page-footer');


           // --- State Variables (Unchanged) ---
           let localSuggestionData = [];
           let currentViewData = []; // Holds the FLAT list from API for the current view
           let weeklyUpdatesData = []; // Holds processed data for the updates preview (MASTER LIST)
           let updatesPreviewShownCount = 0; // Tracks how many are *currently rendered* in the preview
           let uniqueQualities = new Set();
           let activeTableActionRow = null;
           let activePreviewActionRow = null;
           let copyFeedbackTimeout;
           let suggestionDebounceTimeout;
           let searchAbortController = null;
           let isDirectShareLoad = false;
           let currentViewMode = 'homepage';
           let activeResultsTab = 'allFiles';
           let lastFocusedElement = null;

           let currentState = {
               searchTerm: '',
               qualityFilter: '',
               typeFilter: '', // 'movies', 'series', or ''
               sortColumn: 'lastUpdated', // Default sort
               sortDirection: 'desc',
               currentPage: 1,
               limit: config.ITEMS_PER_PAGE,
           };

            const tabMappings = {
               allFiles: { button: allFilesTabButton, panel: allFilesTabPanel, tableBody: allFilesTableBody, pagination: allFilesPaginationControls, typeFilter: '', tableHead: allFilesTableHead },
               movies: { button: moviesTabButton, panel: moviesTabPanel, tableBody: moviesTableBody, pagination: moviesPaginationControls, typeFilter: 'movies', tableHead: moviesTableHead },
               series: { button: seriesTabButton, panel: seriesTabPanel, tableBody: seriesTableBody, pagination: seriesPaginationControls, typeFilter: 'series', tableHead: seriesTableHead }
           };

           // --- Utility Functions (Keep ALL existing: sanitize, TimeAgo, etc.) ---
            const sanitize = (str) => { /* ... */ if (str === null || typeof str === 'undefined') return ""; const temp = document.createElement('div'); temp.textContent = String(str); return temp.innerHTML; };
            const TimeAgo = { MINUTE: 60, HOUR: 3600, DAY: 86400, WEEK: 604800, MONTH: 2592000, YEAR: 31536000, format: (isoString) => { if (!isoString) return 'N/A'; try { const date = new Date(isoString); const seconds = Math.floor((new Date() - date) / 1000); if (isNaN(seconds) || seconds < 0) { console.warn(`TimeAgo: Invalid seconds calculation for ${isoString}. Parsed date: ${date}. Returning full date.`); return TimeAgo.formatFullDate(date); } if (seconds < 2) return "just now"; if (seconds < TimeAgo.MINUTE) return `${seconds} sec${seconds > 1 ? 's' : ''} ago`; if (seconds < TimeAgo.HOUR) return `${Math.floor(seconds / TimeAgo.MINUTE)} min${Math.floor(seconds / TimeAgo.MINUTE) > 1 ? 's' : ''} ago`; if (seconds < TimeAgo.DAY) return `${Math.floor(seconds / TimeAgo.HOUR)} hr${Math.floor(seconds / TimeAgo.HOUR) > 1 ? 's' : ''} ago`; if (seconds < TimeAgo.DAY * 2) return "Yesterday"; if (seconds < TimeAgo.WEEK) return `${Math.floor(seconds / TimeAgo.DAY)} days ago`; if (seconds < TimeAgo.MONTH) return `${Math.floor(seconds / TimeAgo.WEEK)} wk${Math.floor(seconds / TimeAgo.WEEK) > 1 ? 's' : ''} ago`; return TimeAgo.formatFullDate(date, true); } catch (e) { console.error("Date Format Error (TimeAgo):", isoString, e); return 'Invalid Date'; } }, formatFullDate: (date, short = false) => { if (!(date instanceof Date) || isNaN(date.getTime())) return 'Invalid Date'; const optsDate = short ? { year: '2-digit', month: 'numeric', day: 'numeric' } : { year: 'numeric', month: 'short', day: 'numeric' }; const optsTime = { hour: 'numeric', minute: '2-digit', hour12: true }; try { return `${date.toLocaleDateString(undefined, optsDate)}${short ? '' : ', ' + date.toLocaleTimeString(undefined, optsTime)}`; } catch (e) { console.error("toLocaleDateString/Time failed:", e); return `${date.getFullYear()}-${String(date.getMonth()+1).padStart(2,'0')}-${String(date.getDate()).padStart(2,'0')}`; } } };
            function extractSizeData(inputString) { /* ... */ if (!inputString) return { value: 0, unit: '', display: 'N/A', bytes: 0 }; const r = /(?<size>[\d.]+)\s?(?<unit>GB|MB)/i; const m = String(inputString).match(r); if (m?.groups?.size && m?.groups?.unit) { const value = parseFloat(m.groups.size); const unit = m.groups.unit.toUpperCase(); if (!isNaN(value)) { const bytes = unit === 'GB' ? value * 1024 * 1024 * 1024 : value * 1024 * 1024; return { value: value, unit: unit, display: `${value} ${unit}`, bytes: isNaN(bytes) ? 0 : bytes }; } } return { value: 0, unit: '', display: 'N/A', bytes: 0 }; }
            function getMimeTypeFromUrl(url) { /* ... */ if (!url) return 'video/*'; const m = url.match(/\.([a-zA-Z0-9]+)(?:[?#]|$)/); if (!m) return 'video/*'; const ext = m[1].toLowerCase(); const mimeMap = { 'mkv': 'video/x-matroska', 'mp4': 'video/mp4', 'mov': 'video/quicktime', 'avi': 'video/x-msvideo', 'webm': 'video/webm', 'wmv': 'video/x-ms-wmv', 'flv': 'video/x-flv', 'ts': 'video/mp2t', 'm4v': 'video/x-m4v', 'ogv': 'video/ogg' }; return mimeMap[ext] || 'video/*'; }
            function handleVideoError(event) { /* ... */ console.error("HTML5 Video Error:", event, videoElement?.error); let msg = "An unknown error occurred while trying to play the video."; if (videoElement?.error) { switch (videoElement.error.code) { case MediaError.MEDIA_ERR_ABORTED: msg = 'Playback was aborted.'; break; case MediaError.MEDIA_ERR_NETWORK: msg = 'A network error caused the video download to fail.'; break; case MediaError.MEDIA_ERR_DECODE: msg = 'Video decoding error (unsupported codec or corrupt file?).'; break; case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED: msg = 'Video format not supported or server/network failed.'; break; default: msg = `An unknown video error occurred (Code: ${videoElement.error.code}).`; break; } } if (audioWarningDiv) { audioWarningDiv.innerHTML = `<strong>Playback Error:</strong> ${sanitize(msg)} <br>Consider using 'Copy URL' with an external player (VLC/MX) or 'Play in VLC or MX Player' (Android).`; audioWarningDiv.style.display = 'block'; } } if (videoElement) { videoElement.addEventListener('error', handleVideoError); }
            function extractQualityFromFilename(filename) { /* ... */ if (!filename) return null; const safeFilename = String(filename); const patterns = [ /(?:^|\.|\[|\(|\s|_|-)((?:4k|2160p|1080p|720p|480p))(?=$|\.|\]|\)|\s|_|-)/i, /(?:^|\.|\[|\(|\s|_-)(WEB-?DL|WEBRip|BluRay|BDRip|BRRip|HDTV|HDRip|DVDrip|DVDScr|HDCAM|HC|TC|TS|CAM)(?=$|\.|\]|\)|\s|_|-)/i, /(?:^|\.|\[|\(|\s|_-)(HDR|DV|Dolby.?Vision|HEVC|x265)(?=$|\.|\]|\)|\s|_|-)/i ]; let foundQuality = null; for (const regex of patterns) { const match = safeFilename.match(regex); if (match && match[1]) { let quality = match[1].toUpperCase(); quality = quality.replace(/WEB-?DL/i, 'WEBDL'); quality = quality.replace(/BLURAY/i, 'BluRay'); quality = quality.replace(/DVDRIP/i, 'DVD'); quality = quality.replace(/DOLBY.?VISION/i, 'Dolby Vision'); if (quality === '2160P') quality = '4K'; if (patterns.indexOf(regex) < 2) return quality; if (patterns.indexOf(regex) === 2 && !foundQuality) foundQuality = quality; } } return foundQuality; }
            function normalizeTextForSearch(text) { /* ... */ if (!text) return ""; return String(text) .toLowerCase() .replace(/[.\-_\(\)\[\]]/g, '') .replace(/\s+/g, ' ') .trim(); }
            function escapeRegExp(string) { /* ... */ return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }
            async function copyToClipboard(text, feedbackSpan) { /* ... */ console.log("Attempting to copy:", text); let success = false; if (navigator.clipboard && navigator.clipboard.writeText && window.isSecureContext) { try { await navigator.clipboard.writeText(text); success = true; console.log("navigator.clipboard.writeText SUCCEEDED"); } catch (err) { console.error("Async clipboard write failed:", err); success = false; } } if (!success) { console.warn("Using fallback copy method (execCommand)."); const textArea = document.createElement("textarea"); textArea.value = text; textArea.style.position = "fixed"; textArea.style.top = "-9999px"; textArea.style.left = "-9999px"; textArea.style.opacity = "0"; textArea.setAttribute("readonly", ""); document.body.appendChild(textArea); try { textArea.select(); textArea.setSelectionRange(0, textArea.value.length); success = document.execCommand('copy'); console.log("Fallback execCommand result:", success); } catch (err) { console.error('Fallback copy execCommand failed:', err); success = false; } finally { document.body.removeChild(textArea); } } if (success) { console.log("Copy successful!"); if (feedbackSpan) { showCopyFeedback(feedbackSpan, 'Copied!', false); } } else { console.error("Copy FAILED."); if (feedbackSpan) { showCopyFeedback(feedbackSpan, 'Copy Failed!', true); } else { alert("Copy failed. Please try again or copy manually. Check console for errors (F12)."); } } return success; }

           // --- Data Preprocessing (MODIFIED for Grouping Key) ---
           function preprocessMovieData(movie) {
               const processed = { ...movie };
               processed.id = movie.original_id;
               processed.displayFilename = sanitize(movie.filename || '');
               processed.sizeData = extractSizeData(movie.size_display);
               if (!processed.size_bytes && processed.sizeData.bytes > 0) {
                    processed.size_bytes = processed.sizeData.bytes;
               }
               processed.displayQuality = sanitize(movie.quality || 'N/A');
               if (processed.displayQuality && processed.displayQuality !== 'N/A') {
                   uniqueQualities.add(processed.displayQuality);
               }
               const tsString = movie.last_updated_ts;
               let dateObject = null;
               if (tsString) {
                   try { dateObject = new Date(tsString); } catch(e) { console.warn("Date parse error in preprocessMovieData:", e); }
               }
               processed.lastUpdatedTimestamp = (dateObject && !isNaN(dateObject)) ? dateObject.getTime() : 0;
               processed.numericId = typeof processed.id === 'number' ? processed.id : Infinity;
               processed.searchText = normalizeTextForSearch(`${processed.id || ''} ${processed.displayFilename}`);
               processed.isSeries = !!movie.is_series; // Use provided flag

               // Extract Title, Year, Season for Trailer Link AND Grouping
               processed.extractedTitle = null;
               processed.extractedYear = null;
               processed.extractedSeason = null;

               const filename = processed.displayFilename;
               if (filename) {
                    // Common cleanup for title extraction
                    const cleanTitle = (title) => title ? title.replace(/[._]/g, ' ').replace(/\s+/g, ' ').replace(/ (1080p|720p|2160p|4k|web-?dl|bluray|hdtv|dvdrip|hdr|x265|hevc)$/i, '').trim() : null;

                    // Prioritize Season detection for Series
                    const seasonMatch = filename.match(/[. ]S(\d{1,2})(?:E\d{1,2}|[. ])/i);
                    if (seasonMatch && seasonMatch[1]) {
                       processed.isSeries = true; // Force series if SXX is found
                       processed.extractedSeason = parseInt(seasonMatch[1], 10);
                       const titleEndIndex = seasonMatch.index;
                       processed.extractedTitle = cleanTitle(filename.substring(0, titleEndIndex));
                       // Try to find year before season for series title
                       const yearMatchSeries = processed.extractedTitle?.match(/^(.*)[.(_[](\d{4})[.)_\]]?$/);
                       if (yearMatchSeries && yearMatchSeries[1] && yearMatchSeries[2]) {
                            const year = parseInt(yearMatchSeries[2], 10);
                            if (year > 1900 && year < 2050) {
                                processed.extractedYear = year;
                                processed.extractedTitle = cleanTitle(yearMatchSeries[1]);
                            }
                       }
                    }

                    // If not series or season not found, look for year (Movies)
                   if (!processed.extractedSeason) {
                       const yearMatch = filename.match(/[.(_[](\d{4})[.)_\]]/);
                       if (yearMatch && yearMatch[1]) {
                           const year = parseInt(yearMatch[1], 10);
                           if (year > 1900 && year < 2050) {
                               processed.extractedYear = year;
                               const titleEndIndex = yearMatch.index;
                               processed.extractedTitle = cleanTitle(filename.substring(0, titleEndIndex));
                           }
                       }
                   }

                   // Fallback Title Extraction if still missing
                   if (!processed.extractedTitle) {
                       processed.extractedTitle = cleanTitle(filename.split(/[\.({\[]/)[0]);
                   }
               }

               // *** Generate Grouping Key ***
               const normalizedTitle = normalizeTextForSearch(processed.extractedTitle || processed.displayFilename.split(/[\.({\[]/)[0] || 'untitled');
               const yearPart = processed.extractedYear ? `y${processed.extractedYear}` : 'yunknown';
               const seasonPart = processed.isSeries ? `s${String(processed.extractedSeason || 0).padStart(2, '0')}` : 'movie';
               processed.groupKey = `${seasonPart}-${normalizedTitle}-${yearPart}`;
               // ***************************

               return processed;
           }


           // --- HTML Generation (MODIFIED for Grouping) ---
           function createActionContentHTML(movie) {
                // ... (Keep the existing function - it's used by action rows) ...
               const displayFilename = movie.displayFilename;
               const displaySize = movie.sizeData.display;
               const displayQuality = movie.displayQuality;
               const streamTitle = (displayFilename || '').split(/[\.\(\[]/)[0].replace(/[_ ]+/g, ' ').trim() + (displayQuality !== 'N/A' ? ` (${displayQuality})` : '');
               const timestampString = movie.last_updated_ts;
               const formattedDateRelative = TimeAgo.format(timestampString);
               const dateObject = timestampString ? new Date(timestampString) : null;
               const formattedDateFull = (dateObject && !isNaN(dateObject)) ? TimeAgo.formatFullDate(dateObject) : 'N/A';
               let hdrLogoHtml = ''; let fourkLogoHtml = '';
               const lowerFilename = (displayFilename || '').toLowerCase();
               if (displayQuality === '4K' || lowerFilename.includes('2160p') || lowerFilename.includes('.4k.')) { fourkLogoHtml = `<img src="${config.FOURK_LOGO_URL}" alt="4K" class="quality-logo fourk-logo" title="4K Ultra HD" />`; }
               if ((displayQuality || '').includes('HDR') || (displayQuality || '').includes('DOLBY VISION') || displayQuality === 'DV' || lowerFilename.includes('hdr') || lowerFilename.includes('dolby.vision') || lowerFilename.includes('.dv.')) { hdrLogoHtml = `<img src="${config.HDR_LOGO_URL}" alt="HDR/DV" class="quality-logo hdr-logo" title="HDR / Dolby Vision Content" />`; }
               const escapedStreamTitle = streamTitle.replace(/'/g, "\\'");
               const escapedFilename = displayFilename.replace(/'/g, "\\'");
               const escapedUrl = movie.url ? movie.url.replace(/'/g, "\\'") : '';
               const escapedId = movie.id ? String(movie.id).replace(/'/g, "\\'") : '';

               // Trailer Link Logic
               let youtubeTrailerButtonHTML = '';
               const titleForSearch = movie.extractedTitle || streamTitle;
               const yearForSearch = movie.extractedYear;
               const seasonForSearch = movie.extractedSeason;
               const languages = (movie.languages || '').toLowerCase();
               const includesHindi = languages.includes('hindi');

               if (titleForSearch) {
                   let searchTerms = [titleForSearch];
                   if (movie.isSeries && seasonForSearch) {
                       searchTerms.push(`Season ${seasonForSearch}`);
                   } else if (!movie.isSeries && yearForSearch) {
                       searchTerms.push(String(yearForSearch));
                   }
                   searchTerms.push("Official Trailer");
                   if (includesHindi) {
                       searchTerms.push("Hindi");
                   }
                   const youtubeSearchQuery = encodeURIComponent(searchTerms.join(' '));
                   const youtubeSearchUrl = `https://www.youtube.com/results?search_query=${youtubeSearchQuery}`;
                   const youtubeIconSVG = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" focusable="false"><path d="M21.582,6.186c-0.23-0.86-0.908-1.538-1.768-1.768C18.267,4,12,4,12,4S5.733,4,4.186,4.418 c-0.86,0.23-1.538,0.908-1.768,1.768C2,7.734,2,12,2,12s0,4.266,0.418,5.814c0.23,0.86,0.908,1.538,1.768,1.768 C5.733,20,12,20,12,20s6.267,0,7.814-0.418c0.861-0.23,1.538-0.908,1.768-1.768C22,16.266,22,12,22,12S22,7.734,21.582,6.186z M10,15.464V8.536L16,12L10,15.464z"></path></svg>`;
                   youtubeTrailerButtonHTML = `<a href="${youtubeSearchUrl}" target="_blank" rel="noopener noreferrer" class="button youtube-button">${youtubeIconSVG} Watch Trailer</a>`;
               }

               let actionButtonsHTML = '';
               if (movie.url && movie.url.toLowerCase() !== 'null') {
                   actionButtonsHTML += `<button class="button play-button" data-action="play" data-title="${escapedStreamTitle}" data-url="${escapedUrl}" data-filename="${escapedFilename}"><span aria-hidden="true">▶️</span> Play here</button>`;
               }
               actionButtonsHTML += youtubeTrailerButtonHTML; // Add trailer button
               if (movie.url && movie.url.toLowerCase() !== 'null') {
                   actionButtonsHTML += `<a class="button download-button" href="${sanitize(movie.url)}" download="${displayFilename}" target="_blank" rel="noopener noreferrer"><span aria-hidden="true">💾</span> Direct Download</a>`;
                   actionButtonsHTML += `<button class="button vlc-button" data-action="copy-vlc" data-url="${escapedUrl}"><span aria-hidden="true">📋</span> Copy URL (for VLC/MX)</button><span class="copy-feedback" role="status" aria-live="polite">Copied!</span>`;
                   if (navigator.userAgent.toLowerCase().includes("android")) {
                       actionButtonsHTML += `<button class="button intent-button" data-action="open-intent" data-url="${escapedUrl}"><span aria-hidden="true">📱</span> Play in VLC or MX Player</button>`;
                   }
               }
               if (movie.telegram_link && movie.telegram_link.toLowerCase() !== 'null') actionButtonsHTML += `<a class="button telegram-button" href="${sanitize(movie.telegram_link)}" target="_blank" rel="noopener noreferrer">Telegram File</a>`;
               if (movie.gdflix_link) actionButtonsHTML += `<a class="button gdflix-button" href="${sanitize(movie.gdflix_link)}" target="_blank" rel="noopener noreferrer">GDFLIX</a>`;
               if (movie.hubcloud_link && movie.hubcloud_link.toLowerCase() !== 'null') actionButtonsHTML += `<a class="button hubcloud-button" href="${sanitize(movie.hubcloud_link)}" target="_blank" rel="noopener noreferrer">HubCloud</a>`;
               if (movie.filepress_link) actionButtonsHTML += `<a class="button filepress-button" href="${sanitize(movie.filepress_link)}" target="_blank" rel="noopener noreferrer">Filepress</a>`;
               if (movie.gdtot_link) actionButtonsHTML += `<a class="button gdtot-button" href="${sanitize(movie.gdtot_link)}" target="_blank" rel="noopener noreferrer">GDToT</a>`;
               if (movie.id) { actionButtonsHTML += `<button class="button share-button" data-action="share" data-id="${escapedId}" data-title="${escapedStreamTitle}" data-filename="${escapedFilename}"><span aria-hidden="true">🔗</span> Share Post</button><span class="copy-feedback share-fallback" role="status" aria-live="polite">Link copied!</span>`; }
               if (!actionButtonsHTML) { actionButtonsHTML = '<span style="color: var(--text-muted); font-style: italic; text-align: center; width: 100%; display: block; padding: 10px 0;">No stream/download actions available</span>'; }

               return `
                   <div class="action-info">
                       <span class="info-item"><strong>Filename:</strong> ${displayFilename}</span>
                       <span class="info-item"><strong>Quality:</strong> ${displayQuality} ${fourkLogoHtml}${hdrLogoHtml}</span>
                       <span class="info-item"><strong>Size:</strong> ${displaySize}</span>
                       <span class="info-item"><strong>Language:</strong> ${sanitize(movie.languages || 'N/A')}</span>
                       <span class="info-item"><strong>Updated:</strong> ${formattedDateFull} (${formattedDateRelative})</span>
                       ${movie.originalFilename ? `<span class="info-item"><strong>Original Name:</strong> ${sanitize(movie.originalFilename)}</span>` : ''}
                   </div>
                   <div class="action-buttons-container">
                       ${actionButtonsHTML}
                   </div>`;
           }
           // MODIFIED: Creates row for individual items (used for single items AND children of groups)
           function createMovieTableRowHTML(movie, dataIndex, actionRowId, isChild = false, groupKey = null) {
                const displayFilename = movie.displayFilename;
                const displaySize = movie.sizeData.display;
                const displayQuality = movie.displayQuality;
                const timestampString = movie.last_updated_ts;
                const formattedDateRelative = TimeAgo.format(timestampString);
                const dateObject = timestampString ? new Date(timestampString) : null;
                const formattedDateFull = (dateObject && !isNaN(dateObject)) ? TimeAgo.formatFullDate(dateObject) : 'N/A';
                let hdrLogoHtml = ''; let fourkLogoHtml = '';
                const lowerFilename = (displayFilename || '').toLowerCase();
                if (displayQuality === '4K' || lowerFilename.includes('2160p') || lowerFilename.includes('.4k.')) { fourkLogoHtml = `<img src="${config.FOURK_LOGO_URL}" alt="4K" class="quality-logo fourk-logo" title="4K Ultra HD" />`; }
                if ((displayQuality || '').includes('HDR') || (displayQuality || '').includes('DOLBY VISION') || displayQuality === 'DV' || lowerFilename.includes('hdr') || lowerFilename.includes('dolby.vision') || lowerFilename.includes('.dv.')) { hdrLogoHtml = `<img src="${config.HDR_LOGO_URL}" alt="HDR/DV" class="quality-logo hdr-logo" title="HDR / Dolby Vision Content" />`; }

                const rowClass = isChild ? 'movie-data-row group-child-row' : 'movie-data-row';
                const rowStyle = isChild ? 'style="display: none;"' : ''; // Hide child rows initially
                const groupKeyAttr = groupKey ? `data-group-key="${groupKey}"` : '';

                return `
                    <tr class="${rowClass}" ${rowStyle} data-index="${dataIndex}" data-action-row-id="${actionRowId}" ${groupKeyAttr}>
                        <td class="col-id">${sanitize(movie.id || 'N/A')}</td>
                        <td class="col-filename" title="Click to view details: ${displayFilename}">
                            ${displayFilename}${fourkLogoHtml}${hdrLogoHtml}
                        </td>
                        <td class="col-size">${displaySize}</td>
                        <td class="col-quality">${displayQuality}</td>
                        <td class="col-updated" title="${formattedDateFull}">${formattedDateRelative}</td>
                        <td class="col-view">
                            <button class="button view-button" aria-expanded="false">View</button>
                        </td>
                    </tr>`;
           }
           // NEW: Creates row for group headers
            function createGroupHeaderRowHTML(group) {
                const representativeItem = group.items[0]; // Use the first item (after sorting) to represent
                const groupTitle = representativeItem.extractedTitle || "Group";
                const groupYear = representativeItem.extractedYear ? `(${representativeItem.extractedYear})` : '';
                const groupSeason = representativeItem.isSeries && representativeItem.extractedSeason ? ` Season ${String(representativeItem.extractedSeason).padStart(2, '0')}` : '';
                const itemCount = group.items.length;
                const itemLabel = representativeItem.isSeries ? (itemCount === 1 ? 'Episode' : 'Episodes') : (itemCount === 1 ? 'Version' : 'Versions');

                const displayGroupTitle = `${groupTitle} ${groupYear}${groupSeason} - ${itemCount} ${itemLabel}`;

                // Use representative item's info for date, or display range? Let's use latest update in group.
                 const latestUpdateTs = Math.max(...group.items.map(item => item.lastUpdatedTimestamp || 0));
                 const latestUpdateDate = latestUpdateTs > 0 ? new Date(latestUpdateTs) : null;
                 const formattedDateRelative = latestUpdateDate ? TimeAgo.format(latestUpdateDate.toISOString()) : 'N/A';
                 const formattedDateFull = latestUpdateDate ? TimeAgo.formatFullDate(latestUpdateDate) : 'N/A';


                return `
                    <tr class="group-header-row" data-group-key="${group.key}">
                        <td class="col-id"></td>
                        <td class="col-filename col-filename-group" title="${displayGroupTitle}">${displayGroupTitle}</td>
                        <td class="col-size">Multiple</td>
                        <td class="col-quality">Multiple</td>
                         <td class="col-updated" title="Last updated: ${formattedDateFull}">${formattedDateRelative}</td>
                        <td class="col-view">
                            <button class="button expand-group-button" data-group-key="${group.key}" aria-expanded="false">Expand</button>
                        </td>
                    </tr>`;
            }

           // --- View Control (Unchanged) ---
           function setViewMode(mode) { /* ... Keep existing function ... */ console.log("Setting view mode to:", mode); const previousMode = currentViewMode; currentViewMode = mode; if (mode !== previousMode) { closePlayerIfNeeded(null); } container.classList.toggle('results-active', mode === 'search'); container.classList.toggle('shared-view-active', mode === 'shared'); const showHomepage = mode === 'homepage'; const showSearch = mode === 'search'; const showShared = mode === 'shared'; if (searchFocusArea) searchFocusArea.style.display = (showHomepage || showSearch) ? 'flex' : 'none'; if (resultsArea) resultsArea.style.display = showSearch ? 'block' : 'none'; if (sharedItemView) sharedItemView.style.display = showShared ? 'block' : 'none'; if (updatesPreviewSection) updatesPreviewSection.style.display = showHomepage ? 'block' : 'none'; if (pageFooter) pageFooter.style.display = (showHomepage || showSearch) ? 'flex' : 'none'; if (showHomepage) { if (searchInput) searchInput.value = ''; currentState.searchTerm = ''; if (suggestionsContainer) suggestionsContainer.style.display = 'none'; activeResultsTab = 'allFiles'; currentState.currentPage = 1; currentState.typeFilter = ''; closeActiveActionRow('table', null); closeActiveActionRow('preview', null); if (weeklyUpdatesData.length > 0) { displayInitialUpdates(); } else if (localSuggestionData.length > 0) { if (updatesPreviewList) updatesPreviewList.innerHTML = '<div class="status-message" style="text-align:center; padding: 15px 0;">No recent updates found.</div>'; if (showMoreUpdatesButton) showMoreUpdatesButton.style.display = 'none'; } else { if (updatesPreviewList) updatesPreviewList.innerHTML = `<div class="loading-inline-spinner" role="status" aria-live="polite"><div class="spinner"></div><span>Loading updates...</span></div>`; } document.title = "Cinema Ghar Index"; } else if (showSearch) { closeActiveActionRow('preview', null); document.title = "Cinema Ghar Index"; } else if (showShared) { closeActiveActionRow('table', null); closeActiveActionRow('preview', null); } saveStateToLocalStorage(); }
           window.resetToHomepage = function(event) { /* ... Keep existing function ... */ const triggerElement = event?.target; const wasInSharedView = (currentViewMode === 'shared'); if (!wasInSharedView && window.history.pushState) { const cleanUrl = window.location.origin + window.location.pathname; window.history.pushState({ path: cleanUrl }, '', cleanUrl); } else if (!wasInSharedView) { window.location.hash = ''; } isDirectShareLoad = false; if (wasInSharedView) { console.log("Returning from shared view, performing full page reload to reset."); window.location.href = window.location.origin + window.location.pathname; } else { lastFocusedElement = triggerElement; setViewMode('homepage'); if (searchInput) { setTimeout(() => searchInput.focus(), 100); } } }

           // --- Search and Suggestions Logic (Largely Unchanged) ---
           function handleSearchInput() { /* ... Keep existing function ... */ clearTimeout(suggestionDebounceTimeout); const searchTerm = searchInput.value.trim(); if (searchTerm.length < 2) { suggestionsContainer.style.display = 'none'; return; } suggestionDebounceTimeout = setTimeout(() => { fetchAndDisplaySuggestions(searchTerm); }, config.SUGGESTIONS_DEBOUNCE_DELAY); }
           function fetchAndDisplaySuggestions(term) { /* ... Keep existing function ... */ const normalizedTerm = normalizeTextForSearch(term); if (!normalizedTerm) { suggestionsContainer.style.display = 'none'; return; } const matchingItems = localSuggestionData.filter(movie => movie.searchText.includes(normalizedTerm)).slice(0, config.MAX_SUGGESTIONS); suggestionsContainer.innerHTML = ''; if (matchingItems.length > 0) { const fragment = document.createDocumentFragment(); matchingItems.forEach(item => { const div = document.createElement('div'); let displayText = item.displayFilename; let highlighted = false; if (term.length > 0) { try { const safeTerm = escapeRegExp(term); const regex = new RegExp(`(${safeTerm})`, 'i'); if ((item.displayFilename || '').match(regex)) { div.innerHTML = (item.displayFilename || '').replace(regex, '<strong>$1</strong>'); highlighted = true; } } catch (e) { console.warn("Regex error during highlighting:", e); } } if (!highlighted) { div.textContent = item.displayFilename; } div.title = item.displayFilename; div.onclick = () => selectSuggestion(item.displayFilename); fragment.appendChild(div); }); suggestionsContainer.appendChild(fragment); suggestionsContainer.style.display = 'block'; } else { suggestionsContainer.style.display = 'none'; } }
           function selectSuggestion(selectedValue) { /* ... Keep existing function ... */ searchInput.value = selectedValue; suggestionsContainer.style.display = 'none'; handleSearchSubmit(); }
           window.handleSearchSubmit = function() { /* ... Keep existing function ... */ if (suggestionsContainer) { suggestionsContainer.style.display = 'none'; } const searchTerm = searchInput.value.trim(); console.log("Handling search submit for:", searchTerm); if (searchInput) { searchInput.blur(); } if (searchTerm.length === 0 && currentViewMode !== 'homepage') { resetToHomepage(); return; } if (searchTerm.length === 0 && currentViewMode === 'homepage') { return; } setViewMode('search'); activeResultsTab = 'allFiles'; currentState.currentPage = 1; currentState.searchTerm = searchTerm; currentState.qualityFilter = qualityFilterSelect.value || ''; currentState.typeFilter = ''; updateActiveTabAndPanel(); showLoadingStateInTables(`Searching for "${sanitize(searchTerm)}"...`); fetchAndRenderResults(); }
           function handleSearchClear() { /* ... Keep existing function ... */ clearTimeout(suggestionDebounceTimeout); suggestionsContainer.style.display = 'none'; if (currentViewMode !== 'homepage') { setTimeout(() => { if (searchInput.value.trim() === '') { console.log("Search input cleared via 'x', resetting to homepage."); resetToHomepage(); } }, 100); } else { currentState.searchTerm = ''; saveStateToLocalStorage(); } }
           function showLoadingStateInTables(message = 'Loading...') { /* ... Keep existing function ... */ const loadingHTML = `<tr><td colspan="6" class="loading-message" role="status" aria-live="polite"><div class="spinner"></div>${sanitize(message)}</td></tr>`; Object.values(tabMappings).forEach(mapping => { if (mapping?.tableBody) { mapping.tableBody.innerHTML = loadingHTML; } if (mapping?.pagination) { mapping.pagination.style.display = 'none'; } }); }

           // --- Updates Preview Logic (Unchanged from previous version) ---
            async function loadUpdatesPreview() { /* ... Keep existing function ... */ if (isDirectShareLoad || !updatesPreviewSection || !updatesPreviewList || !showMoreUpdatesButton) return; updatesPreviewList.innerHTML = `<div class="loading-inline-spinner" role="status" aria-live="polite"><div class="spinner"></div><span>Loading updates...</span></div>`; showMoreUpdatesButton.style.display = 'none'; updatesPreviewShownCount = 0; weeklyUpdatesData = []; try { const params = { sort: 'lastUpdated', sortDir: 'desc', limit: config.UPDATES_PREVIEW_INITIAL_COUNT, page: 1 }; const data = await fetchApiData(params); if (data && data.items && data.items.length > 0) { weeklyUpdatesData = data.items.map(preprocessMovieData); displayInitialUpdates(); console.log(`Loaded initial ${weeklyUpdatesData.length} updates. Total pages from API: ${data.totalPages}`); } else { updatesPreviewList.innerHTML = '<div class="status-message" style="text-align:center; padding: 15px 0;">No recent updates found.</div>'; showMoreUpdatesButton.style.display = 'none'; } } catch (error) { console.error("Failed to load updates preview:", error); updatesPreviewList.innerHTML = `<div class="error-message" style="text-align:center; padding: 15px 0;">Could not load updates. ${error.message}</div>`; showMoreUpdatesButton.style.display = 'none'; } }
            function displayInitialUpdates() { /* ... Keep existing function ... */ if (!updatesPreviewList || !showMoreUpdatesButton) return; updatesPreviewList.innerHTML = ''; updatesPreviewShownCount = 0; closeActiveActionRow('preview', null); if (weeklyUpdatesData.length === 0) { updatesPreviewList.innerHTML = '<div class="status-message" style="text-align:center; padding: 15px 0;">No recent updates found.</div>'; showMoreUpdatesButton.style.display = 'none'; return; } const initialCount = Math.min(weeklyUpdatesData.length, config.UPDATES_PREVIEW_INITIAL_COUNT); appendUpdatesToPreview(0, initialCount); updatesPreviewShownCount = initialCount; const potentiallyMore = weeklyUpdatesData.length >= config.UPDATES_PREVIEW_INITIAL_COUNT; if (potentiallyMore) { showMoreUpdatesButton.style.display = 'block'; showMoreUpdatesButton.disabled = false; showMoreUpdatesButton.textContent = "Show More"; } else { showMoreUpdatesButton.style.display = 'none'; } }
            window.appendMoreUpdates = async function() { /* ... Keep existing function ... */ if (!updatesPreviewList || !showMoreUpdatesButton) return; showMoreUpdatesButton.disabled = true; showMoreUpdatesButton.textContent = "Loading..."; const currentPage = Math.floor(weeklyUpdatesData.length / config.UPDATES_PREVIEW_LOAD_MORE_COUNT); const nextPage = currentPage + 1; console.log(`Attempting to load page ${nextPage} for updates preview.`); try { const params = { sort: 'lastUpdated', sortDir: 'desc', limit: config.UPDATES_PREVIEW_LOAD_MORE_COUNT, page: nextPage }; const data = await fetchApiData(params); if (data && data.items && data.items.length > 0) { const newItems = data.items.map(preprocessMovieData); const startIndex = weeklyUpdatesData.length; weeklyUpdatesData.push(...newItems); appendUpdatesToPreview(startIndex, weeklyUpdatesData.length); updatesPreviewShownCount = weeklyUpdatesData.length; console.log(`Loaded ${newItems.length} more updates. Total now: ${updatesPreviewShownCount}. Current API page: ${data.page}, Total API pages: ${data.totalPages}`); if (data.page >= data.totalPages) { showMoreUpdatesButton.textContent = "All Updates Shown"; } else { showMoreUpdatesButton.disabled = false; showMoreUpdatesButton.textContent = "Show More"; } } else { console.log("No more updates found from API."); showMoreUpdatesButton.textContent = "No More Updates"; } } catch (error) { console.error("Failed to load more updates:", error); showMoreUpdatesButton.textContent = "Error Loading"; showMoreUpdatesButton.disabled = false; } }
            function appendUpdatesToPreview(startIndex, endIndex) { /* ... Keep existing function ... */ if (!updatesPreviewList) return; const fragment = document.createDocumentFragment(); const itemsToAppend = weeklyUpdatesData.slice(startIndex, endIndex); itemsToAppend.forEach((movie, indexInSlice) => { const overallIndex = startIndex + indexInSlice; if (!movie) return; const itemDiv = document.createElement('div'); itemDiv.className = 'update-item'; const uniqueIdPart = movie.id ? String(movie.id).replace(/[^a-zA-Z0-9-_]/g, '') : `gen-${overallIndex}`; const actionRowId = `preview-actions-${uniqueIdPart}-${overallIndex}`; itemDiv.dataset.index = overallIndex; itemDiv.dataset.actionRowId = actionRowId; let hdrLogoHtml = ''; let fourkLogoHtml = ''; const lowerFilename = (movie.displayFilename || '').toLowerCase(); if (movie.displayQuality === '4K' || lowerFilename.includes('2160p') || lowerFilename.includes('.4k.')) { fourkLogoHtml = `<img src="${config.FOURK_LOGO_URL}" alt="4K" class="quality-logo fourk-logo" title="4K Ultra HD" />`; } if ((movie.displayQuality || '').includes('HDR') || (movie.displayQuality || '').includes('DOLBY VISION') || movie.displayQuality === 'DV' || lowerFilename.includes('hdr') || lowerFilename.includes('dolby.vision') || lowerFilename.includes('.dv.')) { hdrLogoHtml = `<img src="${config.HDR_LOGO_URL}" alt="HDR/DV" class="quality-logo hdr-logo" title="HDR / Dolby Vision Content" />`; } const timestampString = movie.last_updated_ts; const formattedDateRelative = TimeAgo.format(timestampString); const dateObject = timestampString ? new Date(timestampString) : null; const formattedDateFull = (dateObject && !isNaN(dateObject)) ? TimeAgo.formatFullDate(dateObject) : 'N/A'; itemDiv.innerHTML = ` <div class="preview-col-id" title="ID: ${sanitize(movie.id || 'N/A')}">${sanitize(movie.id || 'N/A')}</div> <div class="preview-col-filename" title="${movie.displayFilename}"> ${sanitize(movie.displayFilename)}${fourkLogoHtml}${hdrLogoHtml} </div> <div class="preview-col-date" title="${formattedDateFull}"> ${formattedDateRelative} </div> <div class="preview-col-view"> <button class="button view-button" aria-expanded="false">View</button> </div> `; fragment.appendChild(itemDiv); const actionRowDiv = document.createElement('div'); actionRowDiv.id = actionRowId; actionRowDiv.className = 'preview-action-row'; actionRowDiv.style.display = 'none'; fragment.appendChild(actionRowDiv); }); const initialLoader = updatesPreviewList.querySelector('.loading-inline-spinner'); if (initialLoader && startIndex === 0) { initialLoader.remove(); } updatesPreviewList.appendChild(fragment); }


           // --- Filtering, Sorting (Trigger API Fetch - Unchanged) ---
           function triggerFilterChange() { /* ... Keep existing function ... */ if (!qualityFilterSelect || currentViewMode !== 'search') return; const newQualityFilter = qualityFilterSelect.value; if (newQualityFilter !== currentState.qualityFilter) { currentState.qualityFilter = newQualityFilter; currentState.currentPage = 1; closePlayerIfNeeded(null); showLoadingStateInTables(`Applying filter: ${sanitize(newQualityFilter || 'All Qualities')}...`); fetchAndRenderResults(); } }
           function handleSort(event) { /* ... Keep existing function ... */ const header = event.target.closest('th.sortable'); if (!header || currentViewMode !== 'search') return; const sortKey = header.dataset.sortKey; if (!sortKey) return; const oldSortColumn = currentState.sortColumn; const oldSortDirection = currentState.sortDirection; if (currentState.sortColumn === sortKey) { currentState.sortDirection = currentState.sortDirection === 'asc' ? 'desc' : 'asc'; } else { currentState.sortColumn = sortKey; currentState.sortDirection = ['filename', 'quality'].includes(sortKey) ? 'asc' : 'desc'; } if (oldSortColumn !== currentState.sortColumn || oldSortDirection !== currentState.sortDirection) { currentState.currentPage = 1; closePlayerIfNeeded(null); showLoadingStateInTables(`Sorting by ${sanitize(sortKey)} (${currentState.sortDirection})...`); fetchAndRenderResults(); } }

           // --- Rendering Logic (MODIFIED for Grouping) ---
           // NEW: Groups items based on the generated groupKey
           function groupResults(items) {
               if (!items || items.length === 0) return [];

               const groups = {};
               items.forEach((item, index) => { // Use original flat list index
                   const key = item.groupKey || `nogroup-${index}`; // Fallback key
                   if (!groups[key]) {
                       groups[key] = {
                           key: key,
                           items: [],
                       };
                   }
                   // IMPORTANT: Add the original flat list index to the item within the group
                   item.originalIndex = index;
                   groups[key].items.push(item);
               });

               // Convert groups object to an array
               return Object.values(groups);
           }
           // MODIFIED: Renders grouped or single items
           function renderActiveResultsView(apiResponse) {
                if (currentViewMode !== 'search' || !tabMappings[activeResultsTab]) {
                   if (currentViewMode === 'search') { showLoadingStateInTables('Enter search term above.'); }
                   return;
                }
                console.log(`Rendering results for tab: ${activeResultsTab}`, apiResponse);
                console.time("renderActiveResultsView");

                const { tableBody, pagination, tableHead } = tabMappings[activeResultsTab];
                if (!tableBody || !pagination) {
                   console.error("Missing table body or pagination controls for tab:", activeResultsTab);
                   console.timeEnd("renderActiveResultsView");
                   return;
                }

                const itemsFromApi = apiResponse.items || [];
                const totalItems = apiResponse.totalItems || 0;
                const currentPage = apiResponse.page || 1;
                const totalPages = apiResponse.totalPages || 1;

                // 1. Preprocess all items from API
                currentViewData = itemsFromApi.map(preprocessMovieData);

                // 2. Group the preprocessed items
                const groupedData = groupResults(currentViewData);
                console.log("Grouped Data:", groupedData);

                let tableHtml = '';
                if (totalItems === 0) {
                   let message = `No ${tabMappings[activeResultsTab].typeFilter || 'files'} found`;
                   if (currentState.searchTerm) message += ` matching "${sanitize(currentState.searchTerm)}"`;
                   if (currentState.qualityFilter) message += ` with quality "${sanitize(currentState.qualityFilter)}"`;
                   message += '.';
                   tableHtml = `<tr><td colspan="6" class="status-message">${message}</td></tr>`;
                } else {
                   // 3. Render groups
                   groupedData.forEach(group => {
                       if (group.items.length === 1) {
                           // Render single item row directly
                           const movie = group.items[0];
                           const uniqueIdPart = movie.id ? String(movie.id).replace(/[^a-zA-Z0-9-_]/g, '') : `gen-${movie.originalIndex}`;
                           const actionRowId = `${activeResultsTab}-actions-${uniqueIdPart}-${movie.originalIndex}`;
                           // Pass dataIndex as the item's original index in the flat list
                           tableHtml += createMovieTableRowHTML(movie, movie.originalIndex, actionRowId, false);
                       } else {
                           // Render group header row
                           tableHtml += createGroupHeaderRowHTML(group);
                           // Render child item rows (hidden initially)
                           group.items.forEach(movie => {
                               const uniqueIdPart = movie.id ? String(movie.id).replace(/[^a-zA-Z0-9-_]/g, '') : `gen-${movie.originalIndex}`;
                               const actionRowId = `${activeResultsTab}-actions-${uniqueIdPart}-${movie.originalIndex}`;
                               // Pass dataIndex as the item's original index, mark as child, pass group key
                               tableHtml += createMovieTableRowHTML(movie, movie.originalIndex, actionRowId, true, group.key);
                           });
                       }
                   });
                }

                tableBody.innerHTML = tableHtml;
                renderPaginationControls(pagination, totalItems, currentPage, totalPages); // Pagination based on total individual items
                updateActiveTabAndPanel();
                if (tableHead) updateSortIndicators(tableHead);
                updateFilterIndicator();
                closeActiveActionRow('table', null); // Close any lingering action rows
                console.timeEnd("renderActiveResultsView");
           }
           function renderPaginationControls(targetContainer, totalItems, currentPage, totalPages) { /* ... Keep existing function ... */ if (!targetContainer) return; if (totalItems === 0 || totalPages <= 1) { targetContainer.innerHTML = ''; targetContainer.style.display = 'none'; return; } targetContainer.dataset.totalPages = totalPages; targetContainer.innerHTML = ''; let paginationHTML = ''; const maxPagesToShow = 5; const halfPages = Math.floor(maxPagesToShow / 2); paginationHTML += `<button onclick="changePage(${currentPage - 1})" ${currentPage === 1 ? 'disabled title="First page"' : 'title="Previous page"'}>« Prev</button>`; let startPage, endPage; if (totalPages <= maxPagesToShow + 2) { startPage = 1; endPage = totalPages; } else { startPage = Math.max(2, currentPage - halfPages); endPage = Math.min(totalPages - 1, currentPage + halfPages); if (currentPage - halfPages < 2) { endPage = Math.min(totalPages - 1, maxPagesToShow); } if (currentPage + halfPages > totalPages - 1) { startPage = Math.max(2, totalPages - maxPagesToShow + 1); } } if (startPage > 1) { paginationHTML += `<button onclick="changePage(1)" title="Page 1">1</button>`; if (startPage > 2) { paginationHTML += `<span class="page-info" title="Skipped pages">...</span>`; } } for (let i = startPage; i <= endPage; i++) { paginationHTML += (i === currentPage) ? `<span class="current-page">${i}</span>` : `<button onclick="changePage(${i})" title="Page ${i}">${i}</button>`; } if (endPage < totalPages) { if (endPage < totalPages - 1) { paginationHTML += `<span class="page-info" title="Skipped pages">...</span>`; } paginationHTML += `<button onclick="changePage(${totalPages})" title="Page ${totalPages}">${totalPages}</button>`; } paginationHTML += `<button onclick="changePage(${currentPage + 1})" ${currentPage === totalPages ? 'disabled title="Last page"' : 'title="Next page"'}>Next »</button>`; targetContainer.innerHTML = paginationHTML; targetContainer.style.display = 'block'; }
           function updateSortIndicators(tableHeadElement) { /* ... Keep existing function ... */ if (!tableHeadElement) return; tableHeadElement.querySelectorAll('th.sortable').forEach(th => { th.classList.remove('sort-asc', 'sort-desc'); const sortKey = th.dataset.sortKey; if (sortKey === currentState.sortColumn) { const directionClass = currentState.sortDirection === 'asc' ? 'sort-asc' : 'sort-desc'; th.classList.add(directionClass); th.setAttribute('aria-sort', currentState.sortDirection === 'asc' ? 'ascending' : 'descending'); } else { th.removeAttribute('aria-sort'); } }); }
           function updateFilterIndicator() { /* ... Keep existing function ... */ if(qualityFilterSelect) { qualityFilterSelect.classList.toggle('filter-active', !!currentState.qualityFilter); } }
           function updateActiveTabAndPanel() { /* ... Keep existing function ... */ Object.keys(tabMappings).forEach(tabId => { const mapping = tabMappings[tabId]; const isActive = tabId === activeResultsTab; if (mapping?.button) mapping.button.classList.toggle('active', isActive); if (mapping?.panel) mapping.panel.classList.toggle('active', isActive); }); }


           // --- Pagination and Tab Switching (Unchanged) ---
           window.changePage = function(newPage) { /* ... Keep existing function ... */ if (currentViewMode !== 'search' || newPage < 1 || newPage === currentState.currentPage) { return; } const currentPagination = tabMappings[activeResultsTab]?.pagination; if(currentPagination && currentPagination.dataset.totalPages) { const totalP = parseInt(currentPagination.dataset.totalPages, 10); if(newPage > totalP) { console.log(`Change page request to ${newPage} denied, exceeds total pages (${totalP}).`); return; } } currentState.currentPage = newPage; closePlayerIfNeeded(null); fetchAndRenderResults().then(() => { const activeTableBody = tabMappings[activeResultsTab]?.tableBody; scrollToTopOfActiveTable(activeTableBody); }); saveStateToLocalStorage(); }
           function scrollToTopOfActiveTable(tableBodyElement) { /* ... Keep existing function ... */ if (!tableBodyElement) return; const tableContainer = tableBodyElement.closest('.table-container'); if (tableContainer) { const searchBarArea = container.querySelector('#search-focus-area'); const backButtonElem = resultsArea.querySelector('#backToHomeButtonResults'); const filterArea = resultsArea.querySelector('.results-filter-area'); const tabNav = resultsArea.querySelector('.tab-navigation'); let stickyHeaderHeight = 0; if (container.classList.contains('results-active')) { stickyHeaderHeight = (searchBarArea?.offsetHeight || 0) + (backButtonElem?.offsetHeight || 0) + (backButtonElem ? parseFloat(getComputedStyle(backButtonElem).marginBottom) : 0) + (filterArea?.offsetHeight || 0) + (tabNav?.offsetHeight || 0); } const elementTop = tableContainer.getBoundingClientRect().top + window.pageYOffset; const scrollPosition = elementTop - stickyHeaderHeight - 20; window.scrollTo({ top: scrollPosition, behavior: 'smooth' }); } }
           window.switchTab = function(tabId) { /* ... Keep existing function ... */ if (currentViewMode !== 'search' || tabId === activeResultsTab || !tabMappings[tabId]) { return; } activeResultsTab = tabId; currentState.currentPage = 1; currentState.typeFilter = tabMappings[tabId].typeFilter; closePlayerIfNeeded(null); closeActiveActionRow('table', null); updateActiveTabAndPanel(); showLoadingStateInTables(`Loading ${tabMappings[tabId].typeFilter || 'all files'}...`); fetchAndRenderResults(); saveStateToLocalStorage(); }

           // --- Action Row & Group Logic (MODIFIED) ---
           function closeActiveActionRow(type = 'any', elementToFocusAfter = null) {
               let rowToClose = null;
               let mainElement = null;
               let buttonElement = null;

               if ((type === 'table' || type === 'any') && activeTableActionRow) {
                   rowToClose = activeTableActionRow;
                   mainElement = rowToClose.previousElementSibling; // Might be header or movie row
                   // Try finding button on the main element if it's a standard row
                   if (mainElement && mainElement.matches('.movie-data-row')) {
                       buttonElement = mainElement.querySelector('.view-button');
                   }
                   activeTableActionRow = null;
               } else if ((type === 'preview' || type === 'any') && activePreviewActionRow) {
                    // Preview logic unchanged
                   rowToClose = activePreviewActionRow;
                   mainElement = rowToClose.previousElementSibling;
                   if (mainElement) buttonElement = mainElement.querySelector('.view-button');
                   activePreviewActionRow = null;
               }

               if (rowToClose && rowToClose.style.display !== 'none') {
                   const isPlayerInside = videoContainer?.parentElement === rowToClose || (rowToClose.matches('tr.action-row') && videoContainer?.parentElement === rowToClose.querySelector('td')) || (rowToClose.matches('.preview-action-row') && videoContainer?.parentElement === rowToClose);

                   if (isPlayerInside) {
                       closePlayer(elementToFocusAfter || buttonElement || mainElement);
                   }

                   rowToClose.style.display = 'none';

                   if (mainElement && mainElement.matches('.movie-data-row, .update-item')) {
                       mainElement.classList.remove('active-main-row');
                   }

                   if (buttonElement && buttonElement.matches('.view-button')) { // Check if it's the view button
                       buttonElement.textContent = 'View';
                       buttonElement.setAttribute('aria-expanded', 'false');
                   }

                   if (rowToClose.classList.contains('preview-action-row')) {
                       rowToClose.innerHTML = '';
                   } else if (rowToClose.matches('tr.action-row')) {
                       // Detach action row instead of removing completely, might be reused
                       if (rowToClose.parentElement) {
                            // rowToClose.remove(); // Maybe just hide? Let's remove for now.
                            rowToClose.remove();
                       }
                   }

                   if (!isPlayerInside && elementToFocusAfter && typeof elementToFocusAfter.focus === 'function') {
                       // Avoid focusing if the element causing the close is inside the row being closed
                       if(!rowToClose.contains(elementToFocusAfter)) {
                           setTimeout(() => elementToFocusAfter.focus(), 50);
                       }
                   }
               }
           }
           // MODIFIED: Handles action row toggling for both single items and group children
           function toggleTableActions(mainRowElement, triggerElement = null) {
               if (!mainRowElement || !mainRowElement.matches('.movie-data-row')) return; // Only trigger on actual item rows

               // Get the original flat data index
               const dataIndex = parseInt(mainRowElement.dataset.index, 10);
               // Get action row ID (consistent for an item regardless of grouping)
               const targetRowId = mainRowElement.dataset.actionRowId;
               // Get group key if it's a child
               const groupKey = mainRowElement.dataset.groupKey;

               if (isNaN(dataIndex) || dataIndex < 0 || dataIndex >= currentViewData.length || !targetRowId) {
                   console.error("Invalid data attributes or index on table row:", mainRowElement, dataIndex, currentViewData.length);
                   return;
               }

               const buttonElement = mainRowElement.querySelector('.view-button');
               if (!buttonElement) {
                   console.error("Could not find view button in row:", mainRowElement);
                   return;
               }

               const isCurrentlyAssociatedActiveRow = activeTableActionRow && activeTableActionRow.id === targetRowId;
               const elementToFocusAfterClose = triggerElement || buttonElement;

               // Close any other active row (table or preview) *before* potentially opening a new one
               if (!isCurrentlyAssociatedActiveRow) {
                   closePlayerIfNeeded(elementToFocusAfterClose);
                   closeActiveActionRow('any', elementToFocusAfterClose);
               }

               if (isCurrentlyAssociatedActiveRow) {
                   // If clicking the button for the currently open action row, close it.
                   closeActiveActionRow('table', elementToFocusAfterClose);
               } else {
                   // Open the action row for this specific item
                   const movie = currentViewData[dataIndex]; // Get data using the flat index
                   if (!movie) {
                       console.error("Movie data not found for index:", dataIndex);
                       return;
                   }

                   let targetRow = document.getElementById(targetRowId);
                   const actionHTML = createActionContentHTML(movie);
                   const colspanValue = mainRowElement.cells.length || 6;

                   if (!targetRow) {
                       targetRow = document.createElement('tr');
                       targetRow.id = targetRowId;
                       targetRow.className = 'action-row';
                       // Add group key if the main row has it
                       if (groupKey) {
                            targetRow.dataset.groupKey = groupKey;
                       }
                       targetRow.innerHTML = `<td colspan="${colspanValue}">${actionHTML}</td>`;
                       // Insert after the clicked movie row
                       mainRowElement.parentNode.insertBefore(targetRow, mainRowElement.nextSibling);
                   } else {
                       // Row exists, just update content and make visible
                       targetRow.innerHTML = `<td colspan="${colspanValue}">${actionHTML}</td>`;
                        if (groupKey) {
                            targetRow.dataset.groupKey = groupKey;
                       }
                   }

                   targetRow.style.display = 'table-row'; // Make it visible
                   buttonElement.textContent = 'Hide';
                   buttonElement.setAttribute('aria-expanded', 'true');
                   mainRowElement.classList.add('active-main-row');
                   activeTableActionRow = targetRow; // Set this as the active row

                   focusFirstElementInContainer(targetRow);
                   scrollToRowIfNeeded(mainRowElement);
               }
           }
           // NEW: Handles group expansion/collapse
            function toggleGroupExpansion(buttonElement) {
                const groupKey = buttonElement.dataset.groupKey;
                const tableBody = buttonElement.closest('tbody');
                if (!groupKey || !tableBody) return;

                const isExpanding = buttonElement.getAttribute('aria-expanded') === 'false';
                const childItemRows = tableBody.querySelectorAll(`tr.group-child-row[data-group-key="${groupKey}"]`);

                if (isExpanding) {
                    // Expand: Show child rows
                    childItemRows.forEach(row => row.style.display = 'table-row');
                    buttonElement.textContent = 'Collapse';
                    buttonElement.setAttribute('aria-expanded', 'true');
                    // Scroll to make header visible if needed
                    scrollToRowIfNeeded(buttonElement.closest('tr'));
                } else {
                    // Collapse: Hide child rows AND any active action row within this group
                    childItemRows.forEach(row => {
                        row.style.display = 'none';
                        // Check if this row's action row is the currently active one
                        const actionRowId = row.dataset.actionRowId;
                        if (activeTableActionRow && activeTableActionRow.id === actionRowId) {
                            closeActiveActionRow('table', buttonElement); // Close player etc. if needed
                        }
                        // Also hide any non-active action rows associated with children
                        const existingActionRow = document.getElementById(actionRowId);
                         if (existingActionRow && existingActionRow.style.display !== 'none') {
                             existingActionRow.style.display = 'none';
                         }
                    });
                    buttonElement.textContent = 'Expand';
                    buttonElement.setAttribute('aria-expanded', 'false');
                }
            }
           function togglePreviewActions(mainItemDiv, triggerElement = null) { /* ... Keep existing function ... */ if (!mainItemDiv || !mainItemDiv.matches('.update-item')) return; const movieIndex = parseInt(mainItemDiv.dataset.index, 10); const targetRowId = mainItemDiv.dataset.actionRowId; if (isNaN(movieIndex) || !targetRowId || movieIndex < 0 || movieIndex >= weeklyUpdatesData.length) { console.error("Invalid data attributes or index on preview item.", mainItemDiv, movieIndex, weeklyUpdatesData.length); return; } const targetRowDiv = document.getElementById(targetRowId); const buttonElement = mainItemDiv.querySelector('.view-button'); if (!targetRowDiv || !buttonElement) { console.error("Target action div or button not found.", targetRowId); return; } const isCurrentlyAssociatedActiveRow = activePreviewActionRow && activePreviewActionRow.id === targetRowId; const elementToFocusAfterClose = triggerElement || buttonElement; if (!isCurrentlyAssociatedActiveRow) { closePlayerIfNeeded(elementToFocusAfterClose); closeActiveActionRow('any', elementToFocusAfterClose); } if (isCurrentlyAssociatedActiveRow) { closeActiveActionRow('preview', elementToFocusAfterClose); } else { const movie = weeklyUpdatesData[movieIndex]; if (!movie) { console.error("Movie data not found for preview index:", movieIndex); return; } const actionContentHTML = createActionContentHTML(movie); targetRowDiv.innerHTML = actionContentHTML; targetRowDiv.style.display = 'block'; buttonElement.textContent = 'Hide'; buttonElement.setAttribute('aria-expanded', 'true'); mainItemDiv.classList.add('active-main-row'); activePreviewActionRow = targetRowDiv; focusFirstElementInContainer(targetRowDiv); scrollToRowIfNeeded(mainItemDiv); } }
           function scrollToRowIfNeeded(mainElement) { /* ... Keep existing function ... */ setTimeout(() => { mainElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); }, 100); }
           function focusFirstElementInContainer(containerElement) { /* ... Keep existing function ... */ if (!containerElement) return; const firstFocusable = containerElement.querySelector('button, a[href]'); if (firstFocusable) { setTimeout(() => firstFocusable.focus(), 50); } }

           // --- Share Logic (Unchanged) ---
           async function handleShareClick(buttonElement) { /* ... Keep existing function ... */ const itemId = buttonElement.dataset.id; const itemTitle = buttonElement.dataset.title || "Cinema Ghar Item"; const itemFilename = buttonElement.dataset.filename || ""; if (!itemId) { console.error("Share failed: Item ID missing."); alert("Cannot share this item (missing ID)."); return; } const shareUrl = `${window.location.origin}${window.location.pathname}?shareId=${encodeURIComponent(itemId)}`; const shareText = `Check out: ${itemTitle}\n${itemFilename ? `(${itemFilename})\n` : ''}`; const feedbackSpan = buttonElement.nextElementSibling; if (!feedbackSpan || !feedbackSpan.classList.contains('copy-feedback')) { console.warn("Share fallback feedback span not found next to button:", buttonElement); } if (navigator.share) { try { await navigator.share({ title: itemTitle, text: shareText, url: shareUrl, }); console.log('Successful share'); } catch (error) { console.error('Error sharing:', error); if (error.name !== 'AbortError') { if (feedbackSpan) { showCopyFeedback(feedbackSpan, 'Share failed!', true); } else { alert(`Share failed: ${error.message}`); } } } } else { console.log('Web Share API not supported, falling back to copy.'); await copyToClipboard(shareUrl, feedbackSpan); } }

           // --- Shared Item Display Logic (Unchanged) ---
           async function displaySharedItem(shareId) { /* ... Keep existing function ... */ if (!shareId || !sharedItemView || !sharedItemContent) return; sharedItemContent.innerHTML = `<div class="loading-inline-spinner" role="status" aria-live="polite"><div class="spinner"></div><span>Loading shared item...</span></div>`; setViewMode('shared'); try { const params = { id: shareId }; const data = await fetchApiData(params); if (data && data.items && data.items.length > 0) { const sharedMovieRaw = data.items[0]; const sharedMovie = preprocessMovieData(sharedMovieRaw); console.log("Displaying shared item:", sharedMovie.displayFilename); const actionHTML = createActionContentHTML(sharedMovie); sharedItemContent.innerHTML = actionHTML; document.title = `${sharedMovie.displayFilename || 'Shared Item'} - Cinema Ghar`; if (videoContainer) videoContainer.style.display = 'none'; } else { console.error("Shared item not found via API for ID:", shareId); sharedItemContent.innerHTML = `<div class="error-message" role="alert">Error: Shared item with ID ${sanitize(shareId)} was not found. It might have been removed or the link is incorrect.</div>`; document.title = "Item Not Found - Cinema Ghar Index"; } } catch (error) { console.error("Failed to fetch shared item:", error); sharedItemContent.innerHTML = `<div class="error-message" role="alert">Error loading shared item: ${error.message}. Please try again.</div>`; document.title = "Error Loading Item - Cinema Ghar Index"; } finally { setViewMode('shared'); window.scrollTo({ top: 0, behavior: 'smooth' }); } }

           // --- Player Logic (Unchanged - Relies on Action Row placement) ---
           function streamVideo(title, url, filenameForAudioCheck) { /* ... Keep existing function ... */ let currentActionContainer = null; if (currentViewMode === 'shared' && sharedItemContent) { currentActionContainer = sharedItemContent; } else { const currentActiveRow = activeTableActionRow || activePreviewActionRow; if (!currentActiveRow) { console.error("Cannot stream: active action row/div missing."); return; } currentActionContainer = currentActiveRow.matches('tr.action-row') ? currentActiveRow.querySelector('td') : currentActiveRow.matches('.preview-action-row') ? currentActiveRow : null; } if (!videoContainer || !videoElement || !currentActionContainer) { console.error("Cannot stream: player, video element, or action container missing.", { videoContainer, videoElement, currentActionContainer }); return; } if (videoContainer.parentElement !== currentActionContainer) { console.log("Moving video container to active container."); if (videoElement && videoElement.hasAttribute('src')) { videoElement.pause(); videoElement.removeAttribute('src'); videoElement.currentTime = 0; videoElement.load(); } if (vlcBox) vlcBox.style.display = 'none'; if (audioWarningDiv) audioWarningDiv.style.display = 'none'; if (audioTrackSelect) { audioTrackSelect.innerHTML = ''; audioTrackSelect.style.display = 'none'; } clearCopyFeedback(); currentActionContainer.appendChild(videoContainer); } if (audioWarningDiv) { audioWarningDiv.style.display = 'none'; audioWarningDiv.innerHTML = ''; } if (audioTrackSelect) { audioTrackSelect.innerHTML = ''; audioTrackSelect.style.display = 'none'; } clearCopyFeedback(); const savedVolume = localStorage.getItem(config.PLAYER_VOLUME_KEY); const savedSpeed = localStorage.getItem(config.PLAYER_SPEED_KEY); videoElement.volume = (savedVolume !== null) ? Math.max(0, Math.min(1, parseFloat(savedVolume))) : 1; if (volumeSlider) volumeSlider.value = videoElement.volume; videoElement.muted = (videoElement.volume === 0); videoElement.playbackRate = (savedSpeed !== null) ? parseFloat(savedSpeed) : 1; if(playbackSpeedSelect) playbackSpeedSelect.value = String(videoElement.playbackRate); updateMuteButton(); videoElement.currentTime = 0; const ddp51Regex = /\bDDP?([ ._-]?5\.1)?\b/i; const advancedAudioRegex = /\b(DTS|ATMOS|TrueHD)\b/i; const multiAudioHintRegex = /\b(Multi|Dual)[ ._-]?Audio\b/i; let warningText = ""; if (filenameForAudioCheck) { const lowerFilename = (filenameForAudioCheck || '').toLowerCase(); if (ddp51Regex.test(lowerFilename)) { warningText = "<strong>Audio Note:</strong> DDP audio might not work in browser. Use 'Copy URL' or 'Play in VLC or MX Player'."; } else if (advancedAudioRegex.test(lowerFilename)) { warningText = "<strong>Audio Note:</strong> DTS/Atmos/TrueHD audio likely unsupported. Use external player."; } else if (multiAudioHintRegex.test(lowerFilename)) { warningText = "<strong>Audio Note:</strong> May contain multiple audio tracks. Use selector below or external player."; } } if (warningText && audioWarningDiv) { audioWarningDiv.innerHTML = warningText; audioWarningDiv.style.display = 'block'; } if (videoTitle) videoTitle.innerText = title; if (vlcText) vlcText.innerText = url; if (vlcBox) vlcBox.style.display = 'block'; videoElement.src = url; videoElement.load(); videoElement.play().catch(e => { console.log("Autoplay was prevented or failed:", e.message); }); videoContainer.style.display = 'flex'; const closeButton = videoContainer.querySelector('.close-btn'); if (closeButton) { setTimeout(() => closeButton.focus(), 100); } setTimeout(() => { videoContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); }, 150); }
           window.closePlayer = function(elementToFocusAfter = null) { /* ... Keep existing function ... */ if (elementToFocusAfter instanceof Event) { elementToFocusAfter = elementToFocusAfter?.target; } if (!videoContainer || !videoElement) return; const wasPlaying = videoContainer.style.display !== 'none'; const parentContainer = videoContainer.parentElement; try { const fsElement = document.fullscreenElement || document.webkitFullscreenElement; if (fsElement && (fsElement === videoElement || fsElement === videoContainer)) { if (document.exitFullscreen) document.exitFullscreen(); else if (document.webkitExitFullscreen) document.webkitExitFullscreen(); } } catch(err) { console.error("Error exiting fullscreen:", err); } videoElement.pause(); videoElement.removeAttribute('src'); videoElement.currentTime = 0; videoElement.load(); videoContainer.style.display = 'none'; if (vlcBox) vlcBox.style.display = 'none'; if (audioWarningDiv) { audioWarningDiv.style.display = 'none'; audioWarningDiv.innerHTML = ''; } if (audioTrackSelect) { audioTrackSelect.innerHTML = ''; audioTrackSelect.style.display = 'none'; } clearCopyFeedback(); if (videoTitle) videoTitle.innerText = ''; if (videoContainer.classList.contains('is-fullscreen')) { videoContainer.classList.remove('is-fullscreen'); } const mainBodyContainer = document.getElementById('cinemaghar-container'); if (mainBodyContainer && videoContainer.parentElement !== mainBodyContainer) { mainBodyContainer.appendChild(videoContainer); console.log("Moved video player back to main container."); } else if (!mainBodyContainer) { console.warn("Main container #cinemaghar-container not found, cannot move player back."); } if (wasPlaying && parentContainer?.closest('.action-row, .preview-action-row')) { const parentActionRow = parentContainer.closest('.action-row, .preview-action-row'); if (parentActionRow) { const mainElement = parentActionRow.previousElementSibling; if (mainElement) { const viewButton = mainElement.querySelector('.view-button'); if (viewButton && viewButton.getAttribute('aria-expanded') === 'true') { viewButton.textContent = 'View'; viewButton.setAttribute('aria-expanded', 'false'); } mainElement.classList.remove('active-main-row'); } if (parentActionRow.style.display !== 'none') { parentActionRow.style.display = 'none'; if (parentActionRow.classList.contains('preview-action-row')) { parentActionRow.innerHTML = ''; } } } } else if (wasPlaying && currentViewMode === 'shared') { console.log("Closed player within shared view."); } let finalFocusTarget = elementToFocusAfter || lastFocusedElement; const closedRowId = parentContainer?.closest('.action-row, .preview-action-row')?.id; if (activeTableActionRow?.id === closedRowId || activePreviewActionRow?.id === closedRowId) { finalFocusTarget = null; } if (finalFocusTarget && typeof finalFocusTarget.focus === 'function') { console.log("Returning focus to:", finalFocusTarget); setTimeout(() => finalFocusTarget.focus(), 50); } lastFocusedElement = null; if (activeTableActionRow && activeTableActionRow.id === closedRowId) { activeTableActionRow = null; } if (activePreviewActionRow && activePreviewActionRow.id === closedRowId) { activePreviewActionRow = null; } }
           function closePlayerIfNeeded(elementToFocusAfter = null) { /* ... Keep existing function ... */ if (videoContainer?.style.display === 'flex' || videoContainer?.style.display === 'block') { closePlayer(elementToFocusAfter); } }
           window.seekVideo = function(seconds) { /* ... Keep existing function ... */ if (videoElement) videoElement.currentTime += seconds; }
           window.toggleMute = function() { /* ... Keep existing function ... */ if (videoElement) videoElement.muted = !videoElement.muted; }
           window.setVolume = function(value) { /* ... Keep existing function ... */ if (videoElement) { const vol = parseFloat(value); videoElement.volume = vol; videoElement.muted = (vol === 0); } }
           window.setPlaybackSpeed = function(value) { /* ... Keep existing function ... */ if (videoElement) videoElement.playbackRate = parseFloat(value); }
           window.toggleFullscreen = function() { /* ... Keep existing function ... */ const elementToMakeFullscreen = videoContainer; if (!elementToMakeFullscreen) return; const fsElement = document.fullscreenElement || document.webkitFullscreenElement; try { if (!fsElement) { if (elementToMakeFullscreen.requestFullscreen) elementToMakeFullscreen.requestFullscreen(); else if (elementToMakeFullscreen.webkitRequestFullscreen) elementToMakeFullscreen.webkitRequestFullscreen(); } else { if (document.exitFullscreen) document.exitFullscreen(); else if (document.webkitExitFullscreen) document.webkitExitFullscreen(); } } catch (err) { console.error("Fullscreen API error:", err); alert("Fullscreen mode failed. Browser might block it."); } }
           window.changeAudioTrack = function(selectElement) { /* ... Keep existing function ... */ if (!videoElement || !videoElement.audioTracks) return; const selectedTrackValue = selectElement.value; const tracks = videoElement.audioTracks; let trackChanged = false; for (let i = 0; i < tracks.length; i++) { const track = tracks[i]; const isSelectedTrack = (track.id && track.id === selectedTrackValue) || String(i) === selectedTrackValue; if (track.enabled !== isSelectedTrack) { try { track.enabled = isSelectedTrack; if (isSelectedTrack) console.log("Enabled audio track:", track.label || track.id || i); trackChanged = true; } catch (e) { console.error("Error changing audio track state for track:", track.id || i, e); } } } if (!trackChanged) console.warn("Selected audio track already active or no change applied."); }
           function togglePlayPause() { /* ... Keep existing function ... */ if (videoElement) { if (videoElement.paused || videoElement.ended) videoElement.play().catch(e => console.log("Play error:", e.message)); else videoElement.pause(); } }
           function updateMuteButton() { /* ... Keep existing function ... */ if (!videoElement || !muteButton) return; const isMuted = videoElement.muted || videoElement.volume === 0; muteButton.textContent = isMuted ? "Unmute" : "Mute"; muteButton.setAttribute('aria-pressed', String(isMuted)); if (volumeSlider) { volumeSlider.style.opacity = isMuted ? '0.5' : '1'; volumeSlider.disabled = isMuted; if (!isMuted && videoElement.volume === 0) { const defaultUnmuteVolume = 0.5; videoElement.volume = defaultUnmuteVolume; volumeSlider.value = defaultUnmuteVolume; } } }
           function handleFullscreenChange() { /* ... Keep existing function ... */ const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement); if (!videoContainer) return; videoContainer.classList.toggle('is-fullscreen', isFullscreen); console.log("Fullscreen state changed:", isFullscreen); }
           function populateAudioTrackSelector() { /* ... Keep existing function ... */ if (!videoElement || typeof videoElement.audioTracks === 'undefined' || !audioTrackSelect) { if(audioTrackSelect) audioTrackSelect.style.display = 'none'; return; } const tracks = videoElement.audioTracks; audioTrackSelect.innerHTML = ''; if (tracks.length <= 1) { audioTrackSelect.style.display = 'none'; return; } let hasEnabledTrack = false; for (let i = 0; i < tracks.length; i++) { if (tracks[i].enabled) hasEnabledTrack = true; } if (!hasEnabledTrack && tracks.length > 0) { try { tracks[0].enabled = true; } catch(e) { console.warn("Could not auto-enable first audio track:", e); } } let preferredTrackIndex = -1; for (let i = 0; i < tracks.length; i++) { const track = tracks[i]; const option = document.createElement('option'); const trackValue = track.id || i; option.value = trackValue; let label = track.label || `Track ${i + 1}`; let languageName = ''; if (track.language) { try { languageName = new Intl.DisplayNames(['en'], { type: 'language' }).of(track.language.split('-')[0]); label += ` (${languageName || track.language})`; } catch (e) { label += ` (${track.language})`; } } option.textContent = label; option.selected = track.enabled; option.disabled = track.readyState === 'ended'; audioTrackSelect.appendChild(option); const lang = track.language?.toLowerCase(); const lbl = label.toLowerCase(); if (preferredTrackIndex === -1 && (lang?.startsWith('hi') || lbl.includes('hindi') || languageName?.toLowerCase() === 'hindi')) { preferredTrackIndex = i; } } if (preferredTrackIndex !== -1) { console.log(`Preferred track found at index ${preferredTrackIndex}. Attempting auto-selection.`); try { let trackChanged = false; for (let i = 0; i < tracks.length; i++) { const shouldBeEnabled = (i === preferredTrackIndex); if (tracks[i].enabled !== shouldBeEnabled) { tracks[i].enabled = shouldBeEnabled; trackChanged = true; } } const preferredTrackValue = tracks[preferredTrackIndex].id || preferredTrackIndex; audioTrackSelect.value = preferredTrackValue; if (trackChanged) console.log("Successfully auto-selected preferred track."); } catch(e) { console.error("Error auto-selecting preferred audio track:", e); } } else { console.log("No preferred audio track found."); for (let i = 0; i < tracks.length; i++) { if (tracks[i].enabled) { audioTrackSelect.value = tracks[i].id || i; break; } } } audioTrackSelect.style.display = 'inline-block'; try { if (tracks.onchange === null) tracks.onchange = populateAudioTrackSelector; } catch(e) { console.warn("Browser might not support 'onchange' on AudioTrackList", e)} }
           function openWithIntent(url) { /* ... Keep existing function ... */ if (!url) return; const mime = getMimeTypeFromUrl(url); const titleEncoded = encodeURIComponent(videoTitle?.innerText || document.title || 'Video'); const intentUri = `intent:${url}#Intent;type=${mime};action=android.intent.action.VIEW;S.title=${titleEncoded};end`; console.log("Intent:", intentUri); window.location.href = intentUri; }
           function copyVLCLink(buttonElement, url) { /* ... Keep existing function ... */ console.log("Copy VLC button clicked. URL:", url); if (!url) { console.error("copyVLCLink: No URL provided."); alert("Cannot copy: URL is missing."); return; } const feedbackSpan = buttonElement.nextElementSibling; if (!feedbackSpan || !feedbackSpan.classList.contains('copy-feedback')) { console.warn("copyVLCLink: Could not find feedback span immediately after the button:", buttonElement); copyToClipboard(url, null); return; } copyToClipboard(url, feedbackSpan).catch(err => { console.error("Error during copyVLCLink process:", err); alert("Copy failed. Please try again."); if (feedbackSpan) { feedbackSpan.classList.remove('show', 'error'); feedbackSpan.style.display = 'none'; } }); }
           function showCopyFeedback(spanElement, message = 'Copied!', isError = false) { /* ... Keep existing function ... */ if (!spanElement) return; clearTimeout(copyFeedbackTimeout); spanElement.textContent = message; spanElement.classList.toggle('error', isError); spanElement.classList.remove('share-fallback'); if (spanElement.classList.contains('share-fallback')) { spanElement.classList.add('share-fallback'); } spanElement.style.display = 'inline-block'; spanElement.classList.add('show'); copyFeedbackTimeout = setTimeout(() => { spanElement.classList.remove('show', 'error'); setTimeout(() => { if (!spanElement.classList.contains('show')) { spanElement.style.display = 'none'; spanElement.textContent = spanElement.classList.contains('share-fallback') ? 'Link copied!' : 'Copied!'; } }, 300); }, 2500); }
           function clearCopyFeedback() { /* ... Keep existing function ... */ clearTimeout(copyFeedbackTimeout); document.querySelectorAll('.copy-feedback.show').forEach(span => { span.classList.remove('show', 'error'); span.style.display = 'none'; span.textContent = span.classList.contains('share-fallback') ? 'Link copied!' : 'Copied!'; }); }
           function highlightVlcText() { /* ... Keep existing function ... */ const activeContext = activeTableActionRow || activePreviewActionRow || (currentViewMode === 'shared' ? sharedItemContent : null); if (!activeContext) return; const currentVlcText = activeContext.querySelector('#vlcBox code'); if (currentVlcText && currentVlcText.closest('#vlcBox')?.style.display !== 'none') { try { const range = document.createRange(); range.selectNodeContents(currentVlcText); const selection = window.getSelection(); if (selection) { selection.removeAllRanges(); selection.addRange(range); } console.log("Highlighted VLC text as fallback."); } catch (selectErr) { console.warn("Could not highlight VLC text:", selectErr); } } }
           function handlePlayerKeyboardShortcuts(event) { /* ... Keep existing function ... */ if (!videoContainer || videoContainer.style.display !== 'flex' || !videoElement) return; const targetTagName = event.target.tagName.toLowerCase(); if (targetTagName === 'input' || targetTagName === 'select' || targetTagName === 'textarea') return; const key = event.key; let prevented = false; switch (key) { case ' ': case 'k': togglePlayPause(); prevented = true; break; case 'ArrowLeft': seekVideo(-10); prevented = true; break; case 'ArrowRight': seekVideo(10); prevented = true; break; case 'ArrowUp': setVolume(Math.min(videoElement.volume + 0.05, 1)); if(volumeSlider) volumeSlider.value = videoElement.volume; prevented = true; break; case 'ArrowDown': setVolume(Math.max(videoElement.volume - 0.05, 0)); if(volumeSlider) volumeSlider.value = videoElement.volume; prevented = true; break; case 'm': toggleMute(); prevented = true; break; case 'f': toggleFullscreen(); prevented = true; break; } if (prevented) event.preventDefault(); }

           // --- State Persistence (Unchanged) ---
           function saveStateToLocalStorage() { /* ... Keep existing function ... */ try { const stateToSave = {}; if (currentState.sortColumn !== 'lastUpdated') stateToSave.sortColumn = currentState.sortColumn; if (currentState.sortDirection !== 'desc') stateToSave.sortDirection = currentState.sortDirection; if (currentState.qualityFilter !== '') stateToSave.qualityFilter = currentState.qualityFilter; /* Don't save page */ if (Object.keys(stateToSave).length > 0) { localStorage.setItem(config.LOCAL_STORAGE_KEY, JSON.stringify(stateToSave)); console.log("Saved state:", stateToSave); } else { localStorage.removeItem(config.LOCAL_STORAGE_KEY); console.log("State is default, removed saved state."); } } catch (e) { console.error("Failed to save state to localStorage:", e); } }
           function loadStateFromLocalStorage() { /* ... Keep existing function ... */ try { const savedState = localStorage.getItem(config.LOCAL_STORAGE_KEY); if (savedState) { const parsedState = JSON.parse(savedState); currentState.sortColumn = typeof parsedState.sortColumn === 'string' ? parsedState.sortColumn : 'lastUpdated'; currentState.sortDirection = (typeof parsedState.sortDirection === 'string' && ['asc', 'desc'].includes(parsedState.sortDirection)) ? parsedState.sortDirection : 'desc'; currentState.qualityFilter = typeof parsedState.qualityFilter === 'string' ? parsedState.qualityFilter : ''; console.log("Loaded state:", { sortColumn: currentState.sortColumn, sortDirection: currentState.sortDirection, qualityFilter: currentState.qualityFilter }); } else { currentState.sortColumn = 'lastUpdated'; currentState.sortDirection = 'desc'; currentState.qualityFilter = ''; console.log("No saved state found, using defaults."); } } catch (e) { console.error("Failed to load or parse state from localStorage:", e); localStorage.removeItem(config.LOCAL_STORAGE_KEY); currentState.sortColumn = 'lastUpdated'; currentState.sortDirection = 'desc'; currentState.qualityFilter = ''; } currentState.searchTerm = ''; currentState.currentPage = 1; currentState.typeFilter = ''; activeResultsTab = 'allFiles'; activeTableActionRow = null; activePreviewActionRow = null; lastFocusedElement = null; }

           // --- Initial Data Loading and Setup (Unchanged) ---
           async function fetchApiData(params = {}) { /* ... Keep existing function ... */ if (searchAbortController) { searchAbortController.abort(); } searchAbortController = new AbortController(); const signal = searchAbortController.signal; const query = new URLSearchParams(); query.set('page', params.page || currentState.currentPage); query.set('limit', params.limit || currentState.limit); query.set('sort', params.sort || currentState.sortColumn); query.set('sortDir', params.sortDir || currentState.sortDirection); const searchTerm = params.search !== undefined ? params.search : currentState.searchTerm; if (searchTerm) query.set('search', searchTerm); const qualityFilter = params.quality !== undefined ? params.quality : currentState.qualityFilter; if (qualityFilter) query.set('quality', qualityFilter); const typeFilter = params.type !== undefined ? params.type : currentState.typeFilter; if (typeFilter) query.set('type', typeFilter); if (params.id) { query.set('id', params.id); query.delete('search'); query.delete('quality'); query.delete('type'); query.delete('page'); query.delete('limit'); query.delete('sort'); query.delete('sortDir'); } const url = `${config.MOVIE_DATA_API_URL}?${query.toString()}`; console.log(`Fetching API: ${url}`); try { const response = await fetch(url, { signal }); if (!response.ok) { let errorBody = null; try { errorBody = await response.json(); } catch (_) {} const errorDetails = errorBody?.error || errorBody?.details || `Status: ${response.status}`; throw new Error(`API Error: ${errorDetails}`); } const data = await response.json(); console.log(`API data received:`, data); const activePagination = tabMappings[activeResultsTab]?.pagination; if(activePagination && data.totalPages !== undefined) { activePagination.dataset.totalPages = data.totalPages; } return data; } catch (error) { if (error.name === 'AbortError') { console.log('API fetch aborted.'); return null; } console.error(`Error fetching data from ${url}:`, error); throw error; } finally { if (signal === searchAbortController?.signal) { searchAbortController = null; } } }
           async function fetchAndRenderResults() { /* ... Keep existing function ... */ if (currentViewMode !== 'search') return; try { const apiResponse = await fetchApiData(); if (apiResponse === null) return; renderActiveResultsView(apiResponse); saveStateToLocalStorage(); } catch (error) { console.error("Failed to fetch/render search results:", error); const { tableBody } = tabMappings[activeResultsTab]; if (tableBody) { tableBody.innerHTML = `<tr><td colspan="6" class="error-message">Error loading results: ${error.message}. Please try again.</td></tr>`; } Object.values(tabMappings).forEach(m => { if(m.pagination) m.pagination.style.display = 'none'; }); } }
           function populateQualityFilter(items = []) { /* ... Keep existing function ... */ if (!qualityFilterSelect) return; const currentSelectedValue = qualityFilterSelect.value; items.forEach(item => { if (item.displayQuality && item.displayQuality !== 'N/A') { uniqueQualities.add(item.displayQuality); } }); const sortedQualities = [...uniqueQualities].sort((a, b) => { const getScore = (q) => { q = String(q || '').toUpperCase().trim(); const resMatch = q.match(/^(\d{3,4})P$/); if (q === '4K' || q === '2160P') return 100; if (resMatch) return parseInt(resMatch[1], 10); if (q === '1080P') return 90; if (q === '720P') return 80; if (q === '480P') return 70; if (['WEBDL', 'BLURAY', 'BDRIP', 'BRRIP'].includes(q)) return 60; if (['WEBIP', 'HDTV', 'HDRIP'].includes(q)) return 50; if (['DVD', 'DVDRIP'].includes(q)) return 40; if (['DVDSCR', 'HC', 'HDCAM', 'TC', 'TS', 'CAM'].includes(q)) return 30; if (['HDR', 'DOLBY VISION', 'DV', 'HEVC', 'X265'].includes(q)) return 20; return 0; }; const scoreA = getScore(a); const scoreB = getScore(b); if (scoreA !== scoreB) return scoreB - scoreA; return String(a || '').localeCompare(String(b || ''), undefined, { sensitivity: 'base' }); }); while (qualityFilterSelect.options.length > 1) { qualityFilterSelect.remove(1); } sortedQualities.forEach(quality => { if (quality && quality !== 'N/A') { const option = document.createElement('option'); option.value = quality; option.textContent = quality; qualityFilterSelect.appendChild(option); } }); qualityFilterSelect.value = [...qualityFilterSelect.options].some(opt => opt.value === currentSelectedValue) ? currentSelectedValue : ""; updateFilterIndicator(); }
           function displayLoadError(message) { /* ... Keep existing function ... */ const errorHtml = `<div class="error-container" role="alert">${sanitize(message)}</div>`; if (searchFocusArea) searchFocusArea.innerHTML = ''; searchFocusArea.style.display = 'none'; if (resultsArea) resultsArea.innerHTML = ''; resultsArea.style.display = 'none'; if (updatesPreviewSection) updatesPreviewSection.innerHTML = ''; updatesPreviewSection.style.display = 'none'; if (sharedItemContent) sharedItemContent.innerHTML = ''; if (sharedItemView) sharedItemView.style.display = 'none'; if (pageFooter) pageFooter.style.display = 'none'; container.classList.remove('results-active', 'shared-view-active'); if (mainErrorArea) { mainErrorArea.innerHTML = errorHtml; } else if (container) { container.insertAdjacentHTML('afterbegin', errorHtml); } if (pageLoader) pageLoader.style.display = 'none'; }
           async function initializeApp() { /* ... Keep existing function ... */ const urlParams = new URLSearchParams(window.location.search); const shareId = urlParams.get('shareId'); isDirectShareLoad = !!shareId; if (pageLoader) pageLoader.style.display = 'flex'; if (isDirectShareLoad) { console.log("Direct share link detected for ID:", shareId); } else { console.log("Preparing homepage view (pre-data)."); if (searchFocusArea) searchFocusArea.style.display = 'flex'; if (pageFooter) pageFooter.style.display = 'flex'; if (resultsArea) resultsArea.style.display = 'none'; if (sharedItemView) sharedItemView.style.display = 'none'; const defaultMessageHTML = `<tr><td colspan="6" class="status-message">Enter search term above.</td></tr>`; Object.values(tabMappings).forEach(mapping => { if (mapping?.tableBody) mapping.tableBody.innerHTML = defaultMessageHTML; if (mapping?.pagination) mapping.pagination.style.display = 'none'; }); } loadStateFromLocalStorage(); try { if (shareId) { await displaySharedItem(shareId); fetchApiData({limit: 100, sort: 'quality', sortDir: 'asc'}).then(data => { if (data && data.items) { populateQualityFilter(data.items.map(preprocessMovieData)); } }).catch(e => console.warn("Background quality fetch failed", e)); } else { await loadUpdatesPreview(); console.log("Fetching initial data for suggestions..."); const suggestionData = await fetchApiData({ limit: 5000, sort: 'lastUpdated', sortDir: 'desc' }); if(suggestionData && suggestionData.items) { localSuggestionData = suggestionData.items.map(preprocessMovieData); console.log(`Loaded ${localSuggestionData.length} items for suggestions.`); populateQualityFilter(localSuggestionData); } else { console.warn("Could not load initial data for suggestions/quality filter."); } setViewMode('homepage'); } if (qualityFilterSelect) { qualityFilterSelect.value = currentState.qualityFilter || ''; updateFilterIndicator(); } } catch (error) { console.error('FATAL: Failed during app initialization:', error); displayLoadError(`Error initializing app: ${error.message}. Try refreshing.`); } finally { if (pageLoader) pageLoader.style.display = 'none'; } }

           // --- Event Handling Setup (MODIFIED for Group Button) ---
           function handleActionClick(event) {
                // ... (Keep existing action button logic) ...
                const target = event.target;
                const button = target.closest('.action-buttons-container .button');
                 if (button) {
                    const action = button.dataset.action;
                    const url = button.dataset.url;
                    const title = button.dataset.title;
                    const filename = button.dataset.filename;
                    const id = button.dataset.id;
                    lastFocusedElement = button;
                    if (button.classList.contains('youtube-button')) { return; }
                    if (action === 'play' && url && title) { event.preventDefault(); streamVideo(title, url, filename); }
                    else if (action === 'copy-vlc' && url) { event.preventDefault(); copyVLCLink(button, url); }
                    else if (action === 'open-intent' && url) { event.preventDefault(); openWithIntent(url); }
                    else if (action === 'share' && id) { event.preventDefault(); handleShareClick(button); }
                    else if (button.tagName === 'A' && button.href && button.target === '_blank') { return; }
                }
            }
           function handleContentClick(event) {
                const target = event.target;

                // Group Expand/Collapse Button
                const expandButton = target.closest('.expand-group-button');
                if (expandButton) {
                    event.preventDefault();
                    lastFocusedElement = expandButton;
                    toggleGroupExpansion(expandButton);
                    return; // Don't process further if it's an expand button
                }

                // View Button (for Action Rows)
                const viewButton = target.closest('.view-button');
                // Filename Link (for Action Rows)
                const filenameLink = target.closest('td.col-filename:not(.col-filename-group), .preview-col-filename'); // Exclude group header filename

                if (viewButton || filenameLink) {
                    const mainRowOrItem = target.closest('tr.movie-data-row, div.update-item'); // Ensure it's an item row/div
                    if (mainRowOrItem) {
                         event.preventDefault(); // Prevent default only if we found a valid item row
                         lastFocusedElement = viewButton || filenameLink;
                         if (mainRowOrItem.matches('tr.movie-data-row')) {
                            // Only toggle actions if it's NOT a group header row's button/link
                            if (!mainRowOrItem.classList.contains('group-header-row')) {
                                 toggleTableActions(mainRowOrItem, lastFocusedElement);
                            }
                         } else if (mainRowOrItem.matches('div.update-item')) {
                             togglePreviewActions(mainRowOrItem, lastFocusedElement);
                         }
                    }
                    return; // Stop further processing
                }

                // Handle Action Buttons within Action Rows/Shared View
                handleActionClick(event);

                // Handle Player Close Button
                if (target.matches('.close-btn') && target.closest('#videoContainer')) {
                    lastFocusedElement = target;
                    closePlayer(lastFocusedElement);
                    return;
                }
            }

           // --- Event Listener Setup (Ensure delegated listeners cover new interactions) ---
           document.addEventListener('DOMContentLoaded', async () => {
               await initializeApp();
               // Search Input Listeners (Unchanged)
               if (searchInput) {
                    searchInput.addEventListener('input', handleSearchInput);
                    searchInput.addEventListener('keydown', (event) => { if (event.key === 'Enter') { event.preventDefault(); handleSearchSubmit(); } else if (event.key === 'Escape') { suggestionsContainer.style.display = 'none'; } });
                    searchInput.addEventListener('search', handleSearchClear);
                    searchInput.addEventListener('blur', () => { setTimeout(() => { const searchButton = document.getElementById('searchSubmitButton'); if (document.activeElement !== searchInput && !suggestionsContainer.contains(document.activeElement) && document.activeElement !== searchButton) { suggestionsContainer.style.display = 'none'; } }, 150); });
               }
               // Filter Listener (Unchanged)
               if (qualityFilterSelect) { qualityFilterSelect.addEventListener('change', triggerFilterChange); }

               // Delegated Click Listeners (Main Content Areas)
               // Results Area: Handles Sorting, Group Expand, View Buttons, Action Buttons
               if (resultsArea) {
                   resultsArea.addEventListener('click', (event) => {
                       if (event.target.closest('th.sortable')) {
                           handleSort(event);
                       } else {
                           handleContentClick(event); // Consolidated handler
                       }
                   });
               }
               // Updates Preview Area (Unchanged listener, handleContentClick handles logic)
               if (updatesPreviewList) { updatesPreviewList.addEventListener('click', handleContentClick); }
               // Shared Item View (Unchanged listener, handleContentClick handles logic)
               if (sharedItemView) { sharedItemView.addEventListener('click', handleContentClick); }
               // Video Player Container (Unchanged listener, handleContentClick handles logic)
               if (videoContainer) { videoContainer.addEventListener('click', handleContentClick); }

               // Global Listeners (Unchanged)
               document.addEventListener('keydown', handlePlayerKeyboardShortcuts);
               document.addEventListener('click', (event) => { if (searchInput && suggestionsContainer && suggestionsContainer.style.display === 'block') { const searchWrapper = searchInput.closest('.search-input-wrapper'); if (searchWrapper && !searchWrapper.contains(event.target)) { suggestionsContainer.style.display = 'none'; } } if (videoContainer && videoContainer.style.display !== 'none' && !videoContainer.contains(event.target)) { const logicalParent = videoContainer.parentElement?.closest('.action-row, .preview-action-row, #shared-item-content'); const triggerElement = logicalParent?.previousElementSibling; const triggerButton = logicalParent?.querySelector(`[data-action-row-id="${logicalParent.id}"] .view-button`); if ((!logicalParent || !logicalParent.contains(event.target)) && (!triggerElement || !triggerElement.contains(event.target)) && (!triggerButton || !triggerButton.contains(event.target)) ) { console.log("Clicked outside player's logical container and trigger. Closing player."); closePlayer(event.target); } } }, false);
           });

           // --- Player Event Listeners (Unchanged) ---
           if(videoElement) { videoElement.addEventListener('volumechange', () => { if (volumeSlider && Math.abs(parseFloat(volumeSlider.value) - videoElement.volume) > 0.01) { volumeSlider.value = videoElement.volume; } updateMuteButton(); try { localStorage.setItem(config.PLAYER_VOLUME_KEY, String(videoElement.volume)); } catch (e) { console.warn("LocalStorage volume save failed", e); } }); videoElement.addEventListener('ratechange', () => { if(playbackSpeedSelect && playbackSpeedSelect.value !== String(videoElement.playbackRate)) { playbackSpeedSelect.value = String(videoElement.playbackRate); } try { localStorage.setItem(config.PLAYER_SPEED_KEY, String(videoElement.playbackRate)); } catch (e) { console.warn("LocalStorage speed save failed", e); } }); videoElement.addEventListener('loadedmetadata', populateAudioTrackSelector); videoElement.removeEventListener('error', handleVideoError); videoElement.addEventListener('error', handleVideoError); }
           document.addEventListener('fullscreenchange', handleFullscreenChange);
           document.addEventListener('webkitfullscreenchange', handleFullscreenChange);

       })(); // End of IIFE
       // --- END OF INLINED script.js ---
</script>
<!-- END OF UPDATED SCRIPT BLOCK -->

</body>
</html>
